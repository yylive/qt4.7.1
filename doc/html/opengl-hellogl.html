<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- hellogl.qdoc -->
  <title>Qt 4.7: Hello GL Example</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://doc.qt.nokia.com">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global Declarations</a></li> 
			   <li><a href="licensing.html">Licenses and Credits</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
			   <li><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="technology-apis.html">Qt and Key Technologies</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
			   <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
			   <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
			   <li class="defaultLink"><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li> 
			   <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
			   <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="all-examples.html">Examples</a></li>              <li>Hello GL Example</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#glwidget-class-definition">GLWidget Class Definition</a></li>
<li class="level1"><a href="#glwidget-class-implementation">GLWidget Class Implementation</a></li>
<li class="level2"><a href="#widget-construction-and-sizing">Widget Construction and Sizing</a></li>
<li class="level2"><a href="#opengl-initialization">OpenGL Initialization</a></li>
<li class="level2"><a href="#resizing-the-viewport">Resizing the Viewport</a></li>
<li class="level2"><a href="#painting-the-scene">Painting the Scene</a></li>
<li class="level2"><a href="#mouse-handling">Mouse Handling</a></li>
<li class="level1"><a href="#qtlogo-class">QtLogo Class</a></li>
<li class="level1"><a href="#window-class-definition">Window Class Definition</a></li>
<li class="level1"><a href="#window-class-implementation">Window Class Implementation</a></li>
<li class="level1"><a href="#summary">Summary</a></li>
</ul>
</div>
<h1 class="title">Hello GL Example</h1>
<span class="subtitle"></span>
<!-- $$$opengl/hellogl-description -->
<div class="descr"> <a name="details"></a>
<p>Files:</p>
<ul>
<li><a href="opengl-hellogl-glwidget-cpp.html">opengl/hellogl/glwidget.cpp</a></li>
<li><a href="opengl-hellogl-glwidget-h.html">opengl/hellogl/glwidget.h</a></li>
<li><a href="opengl-hellogl-window-cpp.html">opengl/hellogl/window.cpp</a></li>
<li><a href="opengl-hellogl-window-h.html">opengl/hellogl/window.h</a></li>
<li><a href="opengl-hellogl-main-cpp.html">opengl/hellogl/main.cpp</a></li>
<li><a href="opengl-hellogl-hellogl-pro.html">opengl/hellogl/hellogl.pro</a></li>
</ul>
<p>The Hello GL example demonstrates the basic use of the OpenGL-related classes provided with Qt.</p>
<p class="centerAlign"><img src="images/hellogl-example.png" /></p><p>Qt provides the <a href="qglwidget.html">QGLWidget</a> class to enable OpenGL graphics to be rendered within a standard application user interface. By subclassing this class, and providing reimplementations of event handler functions, 3D scenes can be displayed on widgets that can be placed in layouts, connected to other objects using signals and slots, and manipulated like any other widget.</p>
<a name="glwidget-class-definition"></a>
<h2>GLWidget Class Definition</h2>
<p>The <tt>GLWidget</tt> class contains some standard public definitions for the constructor, destructor, <a href="qwidget.html#sizeHint-prop">sizeHint()</a>, and <a href="qwidget.html#minimumSizeHint-prop">minimumSizeHint()</a> functions:</p>
<pre class="highlightedCode brush: cpp"> class GLWidget : public QGLWidget
 {
     Q_OBJECT

 public:
     GLWidget(QWidget *parent = 0);
     ~GLWidget();

     QSize minimumSizeHint() const;
     QSize sizeHint() const;</pre>
<p>We use a destructor to ensure that any OpenGL-specific data structures are deleted when the widget is no longer needed (although in this case nothing needs cleaning up).</p>
<pre class="highlightedCode brush: cpp"> public slots:
     void setXRotation(int angle);
     void setYRotation(int angle);
     void setZRotation(int angle);

 signals:
     void xRotationChanged(int angle);
     void yRotationChanged(int angle);
     void zRotationChanged(int angle);</pre>
<p>The signals and slots are used to allow other objects to interact with the 3D scene.</p>
<pre class="highlightedCode brush: cpp"> protected:
     void initializeGL();
     void paintGL();
     void resizeGL(int width, int height);
     void mousePressEvent(QMouseEvent *event);
     void mouseMoveEvent(QMouseEvent *event);</pre>
<p>OpenGL initialization, viewport resizing, and painting are handled by reimplementing the <a href="qglwidget.html#initializeGL">QGLWidget::initializeGL</a>(), <a href="qglwidget.html#resizeGL">QGLWidget::resizeGL</a>(), and <a href="qglwidget.html#paintGL">QGLWidget::paintGL</a>() handler functions. To enable the user to interact directly with the scene using the mouse, we reimplement <a href="qwidget.html#mousePressEvent">QWidget::mousePressEvent</a>() and <a href="qwidget.html#mouseMoveEvent">QWidget::mouseMoveEvent</a>().</p>
<pre class="highlightedCode brush: cpp"> private:
     QtLogo *logo;
     int xRot;
     int yRot;
     int zRot;
     QPoint lastPos;
     QColor qtGreen;
     QColor qtPurple;
 };</pre>
<p>The rest of the class contains utility functions and variables that are used to construct and hold orientation information for the scene. The <tt>logo</tt> variable will be used to hold a pointer to the QtLogo object which contains all the geometry.</p>
<a name="glwidget-class-implementation"></a>
<h2>GLWidget Class Implementation</h2>
<p>In this example, we split the class into groups of functions and describe them separately. This helps to illustrate the differences between subclasses of native widgets (such as <a href="qwidget.html">QWidget</a> and <a href="qframe.html">QFrame</a>) and <a href="qglwidget.html">QGLWidget</a> subclasses.</p>
<a name="widget-construction-and-sizing"></a>
<h3>Widget Construction and Sizing</h3>
<p>The constructor provides default rotation angles for the scene, sets the pointer to the QtLogo object to null, and sets up some colors for later use.</p>
<pre class="highlightedCode brush: cpp"> GLWidget::GLWidget(QWidget *parent)
     : QGLWidget(QGLFormat(QGL::SampleBuffers), parent)
 {
     logo = 0;
     xRot = 0;
     yRot = 0;
     zRot = 0;

     qtGreen = QColor::fromCmykF(0.40, 0.0, 1.0, 0.0);
     qtPurple = QColor::fromCmykF(0.39, 0.39, 0.0, 0.0);
 }</pre>
<p>We also implement a destructor to release OpenGL-related resources when the widget is deleted:</p>
<pre class="highlightedCode brush: cpp"> GLWidget::~GLWidget()
 {
 }</pre>
<p>In this case nothing requires cleaning up.</p>
<p>We provide size hint functions to ensure that the widget is shown at a reasonable size:</p>
<pre class="highlightedCode brush: cpp"> QSize GLWidget::minimumSizeHint() const
 {
     return QSize(50, 50);
 }

 QSize GLWidget::sizeHint() const
 {
     return QSize(400, 400);
 }</pre>
<p>The widget provides three slots that enable other components in the example to change the orientation of the scene:</p>
<pre class="highlightedCode brush: cpp"> void GLWidget::setXRotation(int angle)
 {
     qNormalizeAngle(angle);
     if (angle != xRot) {
         xRot = angle;
         emit xRotationChanged(angle);
         updateGL();
     }
 }</pre>
<p>In the above slot, the <tt>xRot</tt> variable is updated only if the new angle is different to the old one, the <tt>xRotationChanged()</tt> signal is emitted to allow other components to be updated, and the widget's <a href="qglwidget.html#updateGL">updateGL()</a> handler function is called.</p>
<p>The <tt>setYRotation()</tt> and <tt>setZRotation()</tt> slots perform the same task for rotations measured by the <tt>yRot</tt> and <tt>zRot</tt> variables.</p>
<a name="opengl-initialization"></a>
<h3>OpenGL Initialization</h3>
<p>The <a href="qglwidget.html#initializeGL">initializeGL()</a> function is used to perform useful initialization tasks that are needed to render the 3D scene. These often involve defining colors and materials, enabling and disabling certain rendering flags, and setting other properties used to customize the rendering process.</p>
<pre class="highlightedCode brush: cpp"> void GLWidget::initializeGL()
 {
     qglClearColor(qtPurple.dark());

     logo = new QtLogo(this, 64);
     logo-&gt;setColor(qtGreen.dark());

     glEnable(GL_DEPTH_TEST);
     glEnable(GL_CULL_FACE);
     glShadeModel(GL_SMOOTH);
     glEnable(GL_LIGHTING);
     glEnable(GL_LIGHT0);
     glEnable(GL_MULTISAMPLE);
     static GLfloat lightPosition[4] = { 0.5, 5.0, 7.0, 1.0 };
     glLightfv(GL_LIGHT0, GL_POSITION, lightPosition);
 }</pre>
<p>In this example, we reimplement the function to set the background color, create a QtLogo object instance which will contain all the geometry to display, and set up the rendering process to use a particular shading model and rendering flags.</p>
<a name="resizing-the-viewport"></a>
<h3>Resizing the Viewport</h3>
<p>The <a href="qglwidget.html#resizeGL">resizeGL()</a> function is used to ensure that the OpenGL implementation renders the scene onto a viewport that matches the size of the widget, using the correct transformation from 3D coordinates to 2D viewport coordinates.</p>
<p>The function is called whenever the widget's dimensions change, and is supplied with the new width and height. Here, we define a square viewport based on the length of the smallest side of the widget to ensure that the scene is not distorted if the widget has sides of unequal length:</p>
<pre class="highlightedCode brush: cpp"> void GLWidget::resizeGL(int width, int height)
 {
     int side = qMin(width, height);
     glViewport((width - side) / 2, (height - side) / 2, side, side);

     glMatrixMode(GL_PROJECTION);
     glLoadIdentity();
 #ifdef QT_OPENGL_ES_1
     glOrthof(-0.5, +0.5, -0.5, +0.5, 4.0, 15.0);
 #else
     glOrtho(-0.5, +0.5, -0.5, +0.5, 4.0, 15.0);
 #endif
     glMatrixMode(GL_MODELVIEW);
 }</pre>
<p>A discussion of the projection transformation used is outside the scope of this example. Please consult the OpenGL reference documentation for an explanation of projection matrices.</p>
<a name="painting-the-scene"></a>
<h3>Painting the Scene</h3>
<p>The <a href="qglwidget.html#paintGL">paintGL()</a> function is used to paint the contents of the scene onto the widget. For widgets that only need to be decorated with pure OpenGL content, we reimplement <a href="qglwidget.html#paintGL">QGLWidget::paintGL</a>() <i>instead</i> of reimplementing <a href="qwidget.html#paintEvent">QWidget::paintEvent</a>():</p>
<pre class="highlightedCode brush: cpp"> void GLWidget::paintGL()
 {
     glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
     glLoadIdentity();
     glTranslatef(0.0, 0.0, -10.0);
     glRotatef(xRot / 16.0, 1.0, 0.0, 0.0);
     glRotatef(yRot / 16.0, 0.0, 1.0, 0.0);
     glRotatef(zRot / 16.0, 0.0, 0.0, 1.0);
     logo-&gt;draw();
 }</pre>
<p>In this example, we clear the widget using the background color that we defined in the <a href="qglwidget.html#initializeGL">initializeGL()</a> function, set up the frame of reference for the geometry we want to display, and call the draw method of the QtLogo object to render the scene.</p>
<a name="mouse-handling"></a>
<h3>Mouse Handling</h3>
<p>Just as in subclasses of native widgets, mouse events are handled by reimplementing functions such as <a href="qwidget.html#mousePressEvent">QWidget::mousePressEvent</a>() and <a href="qwidget.html#mouseMoveEvent">QWidget::mouseMoveEvent</a>().</p>
<p>The <a href="qwidget.html#mousePressEvent">mousePressEvent()</a> function simply records the position of the mouse when a button is initially pressed:</p>
<pre class="highlightedCode brush: cpp"> void GLWidget::mousePressEvent(QMouseEvent *event)
 {
     lastPos = event-&gt;pos();
 }</pre>
<p>The <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent()</a> function uses the previous location of the mouse cursor to determine how much the object in the scene should be rotated, and in which direction:</p>
<pre class="highlightedCode brush: cpp"> void GLWidget::mouseMoveEvent(QMouseEvent *event)
 {
     int dx = event-&gt;x() - lastPos.x();
     int dy = event-&gt;y() - lastPos.y();

     if (event-&gt;buttons() &amp; Qt::LeftButton) {
         setXRotation(xRot + 8 * dy);
         setYRotation(yRot + 8 * dx);
     } else if (event-&gt;buttons() &amp; Qt::RightButton) {
         setXRotation(xRot + 8 * dy);
         setZRotation(zRot + 8 * dx);
     }
     lastPos = event-&gt;pos();
 }</pre>
<p>Since the user is expected to hold down the mouse button and drag the cursor to rotate the object, the cursor's position is updated every time a move event is received.</p>
<a name="qtlogo-class"></a>
<h2>QtLogo Class</h2>
<p>This class encapsulates the OpenGL geometry data which will be rendered in the basic 3D scene.</p>
<pre class="highlightedCode brush: cpp"> class QtLogo : public QObject
 {
 public:
     QtLogo(QObject *parent, int d = 64, qreal s = 1.0);
     ~QtLogo();
     void setColor(QColor c);
     void draw() const;
 private:
     void buildGeometry(int d, qreal s);

     QList&lt;Patch *&gt; parts;
     Geometry *geom;
 };</pre>
<p>The geometry is divided into a list of parts which may be rendered in different ways. The data itself is contained in a Geometry structure that includes the vertices, their lighting normals and index values which point into the vertices, grouping them into faces.</p>
<pre class="highlightedCode brush: cpp"> struct Geometry
 {
     QVector&lt;GLushort&gt; faces;
     QVector&lt;QVector3D&gt; vertices;
     QVector&lt;QVector3D&gt; normals;
     void appendSmooth(const QVector3D &amp;a, const QVector3D &amp;n, int from);
     void appendFaceted(const QVector3D &amp;a, const QVector3D &amp;n);
     void finalize();
     void loadArrays() const;
 };</pre>
<p>The data in the Geometry class is stored in <a href="qvector.html">QVector</a>&lt;<a href="qvector3d.html">QVector3D</a>&gt; members which are convenient for use with OpenGL because they expose raw contiguous floating point values via the constData() method. Methods are included for adding new vertex data, either with smooth normals, or facetted normals; and for enabling the geometry ready for rendering.</p>
<pre class="highlightedCode brush: cpp"> class Patch
 {
 public:
     enum Smoothing { Faceted, Smooth };
     Patch(Geometry *);
     void setSmoothing(Smoothing s) { sm = s; }
     void translate(const QVector3D &amp;t);
     void rotate(qreal deg, QVector3D axis);
     void draw() const;
     void addTri(const QVector3D &amp;a, const QVector3D &amp;b, const QVector3D &amp;c, const QVector3D &amp;n);
     void addQuad(const QVector3D &amp;a, const QVector3D &amp;b,  const QVector3D &amp;c, const QVector3D &amp;d);

     GLushort start;
     GLushort count;
     GLushort initv;

     GLfloat faceColor[4];
     QMatrix4x4 mat;
     Smoothing sm;
     Geometry *geom;
 };</pre>
<p>The higher level Patch class has methods for accumulating the geometry one face at a time, and treating collections of faces or &quot;patches&quot; with transformations, applying different colors or smoothing. Although faces may be added as triangles or quads, at the OpenGL level all data is treated as triangles for compatibility with OpenGL/ES.</p>
<pre class="highlightedCode brush: cpp"> void Patch::draw() const
 {
     glPushMatrix();
     qMultMatrix(mat);
     glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE, faceColor);

     const GLushort *indices = geom-&gt;faces.constData();
     glDrawElements(GL_TRIANGLES, count, GL_UNSIGNED_SHORT, indices + start);
     glPopMatrix();
 }</pre>
<p>Drawing a Patch is simply acheived by applying any transformation, and material effect, then drawing the data using the index range for the patch. The model-view matrix is saved and then restored so that any transformation does not affect other parts of the scene.</p>
<pre class="highlightedCode brush: cpp"> void QtLogo::buildGeometry(int divisions, qreal scale)
 {
     qreal cw = cross_width * scale;
     qreal bt = bar_thickness * scale;
     qreal ld = logo_depth * scale;
     qreal th = tee_height *scale;

     RectPrism cross(geom, cw, bt, ld);
     RectPrism stem(geom, bt, th, ld);

     QVector3D z(0.0, 0.0, 1.0);
     cross.rotate(45.0, z);
     stem.rotate(45.0, z);

     qreal stem_downshift = (th + bt) / 2.0;
     stem.translate(QVector3D(0.0, -stem_downshift, 0.0));

     RectTorus body(geom, 0.20, 0.30, 0.1, divisions);

     parts &lt;&lt; stem.parts &lt;&lt; cross.parts &lt;&lt; body.parts;

     geom-&gt;finalize();
 }</pre>
<p>The geometry is built once on construction of the QtLogo, and it is paramaterized on a number of divisions - which controls how &quot;chunky&quot; the curved section of the logo looks - and on a scale, so larger and smaller QtLogo objects can be created without having to use OpenGL scaling (which would force normal recalculation).</p>
<p>The building process is done by helper classes (read the source for full details) which only exist during the build phase, to assemble the parts of the scene.</p>
<pre class="highlightedCode brush: cpp"> void QtLogo::draw() const
 {
     geom-&gt;loadArrays();

     glEnableClientState(GL_VERTEX_ARRAY);
     glEnableClientState(GL_NORMAL_ARRAY);

     for (int i = 0; i &lt; parts.count(); ++i)
         parts[i]-&gt;draw();

     glDisableClientState(GL_VERTEX_ARRAY);
     glDisableClientState(GL_NORMAL_ARRAY);
 }</pre>
<p>Finally the complete QtLogo scene is simply drawn by enabling the data arrays and then iterating over the parts, calling draw() on each one.</p>
<a name="window-class-definition"></a>
<h2>Window Class Definition</h2>
<p>The <tt>Window</tt> class is used as a container for the <tt>GLWidget</tt> used to display the scene:</p>
<pre class="highlightedCode brush: cpp"> class GLWidget;

 class Window : public QWidget
 {
     Q_OBJECT

 public:
     Window();

 protected:
     void keyPressEvent(QKeyEvent *event);

 private:
     QSlider *createSlider();

     GLWidget *glWidget;
     QSlider *xSlider;
     QSlider *ySlider;
     QSlider *zSlider;
 };</pre>
<p>In addition, it contains sliders that are used to change the orientation of the object in the scene.</p>
<a name="window-class-implementation"></a>
<h2>Window Class Implementation</h2>
<p>The constructor constructs an instance of the <tt>GLWidget</tt> class and some sliders to manipulate its contents.</p>
<pre class="highlightedCode brush: cpp"> Window::Window()
 {
     glWidget = new GLWidget;

     xSlider = createSlider();
     ySlider = createSlider();
     zSlider = createSlider();

     connect(xSlider, SIGNAL(valueChanged(int)), glWidget, SLOT(setXRotation(int)));
     connect(glWidget, SIGNAL(xRotationChanged(int)), xSlider, SLOT(setValue(int)));
     connect(ySlider, SIGNAL(valueChanged(int)), glWidget, SLOT(setYRotation(int)));
     connect(glWidget, SIGNAL(yRotationChanged(int)), ySlider, SLOT(setValue(int)));
     connect(zSlider, SIGNAL(valueChanged(int)), glWidget, SLOT(setZRotation(int)));
     connect(glWidget, SIGNAL(zRotationChanged(int)), zSlider, SLOT(setValue(int)));</pre>
<p>We connect the <a href="qabstractslider.html#valueChanged">valueChanged()</a> signal from each of the sliders to the appropriate slots in <tt>glWidget</tt>. This allows the user to change the orientation of the object by dragging the sliders.</p>
<p>We also connect the <tt>xRotationChanged()</tt>, <tt>yRotationChanged()</tt>, and <tt>zRotationChanged()</tt> signals from <tt>glWidget</tt> to the <a href="qabstractslider.html#value-prop">setValue()</a> slots in the corresponding sliders.</p>
<pre class="highlightedCode brush: cpp">     QHBoxLayout *mainLayout = new QHBoxLayout;
     mainLayout-&gt;addWidget(glWidget);
     mainLayout-&gt;addWidget(xSlider);
     mainLayout-&gt;addWidget(ySlider);
     mainLayout-&gt;addWidget(zSlider);
     setLayout(mainLayout);

     xSlider-&gt;setValue(15 * 16);
     ySlider-&gt;setValue(345 * 16);
     zSlider-&gt;setValue(0 * 16);
     setWindowTitle(tr(&quot;Hello GL&quot;));
 }</pre>
<p>The sliders are placed horizontally in a layout alongside the <tt>GLWidget</tt>, and initialized with suitable default values.</p>
<p>The <tt>createSlider()</tt> utility function constructs a <a href="qslider.html">QSlider</a>, and ensures that it is set up with a suitable range, step value, tick interval, and page step value before returning it to the calling function:</p>
<pre class="highlightedCode brush: cpp"> QSlider *Window::createSlider()
 {
     QSlider *slider = new QSlider(Qt::Vertical);
     slider-&gt;setRange(0, 360 * 16);
     slider-&gt;setSingleStep(16);
     slider-&gt;setPageStep(15 * 16);
     slider-&gt;setTickInterval(15 * 16);
     slider-&gt;setTickPosition(QSlider::TicksRight);
     return slider;
 }</pre>
<a name="summary"></a>
<h2>Summary</h2>
<p>The <tt>GLWidget</tt> class implementation shows how to subclass <a href="qglwidget.html">QGLWidget</a> for the purposes of rendering a 3D scene using OpenGL calls. Since <a href="qglwidget.html">QGLWidget</a> is a subclass of <a href="qwidget.html">QWidget</a>, subclasses of <a href="qglwidget.html">QGLWidget</a> can be placed in layouts and provided with interactive features just like normal custom widgets.</p>
<p>We ensure that the widget is able to correctly render the scene using OpenGL by reimplementing the following functions:</p>
<ul>
<li><a href="qglwidget.html#initializeGL">QGLWidget::initializeGL</a>() sets up resources needed by the OpenGL implementation to render the scene.</li>
<li><a href="qglwidget.html#resizeGL">QGLWidget::resizeGL</a>() resizes the viewport so that the rendered scene fits onto the widget, and sets up a projection matrix to map 3D coordinates to 2D viewport coordinates.</li>
<li><a href="qglwidget.html#paintGL">QGLWidget::paintGL</a>() performs painting operations using OpenGL calls.</li>
</ul>
<p>Since <a href="qglwidget.html">QGLWidget</a> is a subclass of <a href="qwidget.html">QWidget</a>, it can also be used as a normal paint device, allowing 2D graphics to be drawn with <a href="qpainter.html">QPainter</a>. This use of <a href="qglwidget.html">QGLWidget</a> is discussed in the <a href="opengl-2dpainting.html">2D Painting</a> example.</p>
<p>More advanced users may want to paint over parts of a scene rendered using OpenGL. <a href="qglwidget.html">QGLWidget</a> allows pure OpenGL rendering to be mixed with <a href="qpainter.html">QPainter</a> calls, but care must be taken to maintain the state of the OpenGL implementation. See the <a href="opengl-overpainting.html">Overpainting</a> example for more information.</p>
</div>
<!-- @@@opengl/hellogl -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
    <br />
    <p>
      Licensees holding valid Qt Commercial licenses may use this document in accordance with the      Qt Commercial License Agreement provided with the Software or, alternatively, in accordance      with the terms contained in a written agreement between you and Nokia.</p>
    <p>
      Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
      Free Documentation License version 1.3</a>
      as published by the Free Software Foundation.</p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback.</p> <p class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
</body>
</html>
