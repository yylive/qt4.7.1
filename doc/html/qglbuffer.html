<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qglbuffer.cpp -->
  <title>Qt 4.7: QGLBuffer Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://doc.qt.nokia.com">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global Declarations</a></li> 
			   <li><a href="licensing.html">Licenses and Credits</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
			   <li><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="technology-apis.html">Qt and Key Technologies</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
			   <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
			   <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
			   <li class="defaultLink"><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li> 
			   <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
			   <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="modules.html">Modules</a></li>              <li><a href="qtopengl.html">QtOpenGL</a></li>
              <li>QGLBuffer</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QGLBuffer Class Reference</h1>
<!-- $$$QGLBuffer-brief -->
<p>The QGLBuffer class provides functions for creating and managing GL buffer objects. <a href="#details">More...</a></p>
<!-- @@@QGLBuffer -->
<pre class="highlightedCode brush: cpp"> #include &lt;QGLBuffer&gt;</pre><p>This class was introduced in Qt 4.7.</p>
<ul>
<li><a href="qglbuffer-members.html">List of all members, including inherited members</a></li>
</ul>
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#Access-enum">Access</a></b> { ReadOnly, WriteOnly, ReadWrite }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#Type-enum">Type</a></b> { VertexBuffer, IndexBuffer, PixelPackBuffer, PixelUnpackBuffer }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#UsagePattern-enum">UsagePattern</a></b> { StreamDraw, StreamRead, StreamCopy, StaticDraw, ..., DynamicCopy }</td></tr>
</table>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#QGLBuffer">QGLBuffer</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#QGLBuffer-2">QGLBuffer</a></b> ( QGLBuffer::Type <i>type</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#QGLBuffer-3">QGLBuffer</a></b> ( const QGLBuffer &amp; <i>other</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#dtor.QGLBuffer">~QGLBuffer</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#allocate">allocate</a></b> ( const void * <i>data</i>, int <i>count</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#allocate-2">allocate</a></b> ( int <i>count</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#bind">bind</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#bufferId">bufferId</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#create">create</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#destroy">destroy</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#isCreated">isCreated</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void * </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#map">map</a></b> ( QGLBuffer::Access <i>access</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#read">read</a></b> ( int <i>offset</i>, void * <i>data</i>, int <i>count</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#release">release</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#setUsagePattern">setUsagePattern</a></b> ( QGLBuffer::UsagePattern <i>value</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#size">size</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLBuffer::Type </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#type">type</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#unmap">unmap</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLBuffer::UsagePattern </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#usagePattern">usagePattern</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#write">write</a></b> ( int <i>offset</i>, const void * <i>data</i>, int <i>count</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLBuffer &amp; </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#operator-eq">operator=</a></b> ( const QGLBuffer &amp; <i>other</i> )</td></tr>
</table>
<a name="static-public-members"></a>
<h2>Static Public Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglbuffer.html#release-2">release</a></b> ( QGLBuffer::Type <i>type</i> )</td></tr>
</table>
<a name="details"></a>
<!-- $$$QGLBuffer-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QGLBuffer class provides functions for creating and managing GL buffer objects.</p>
<p>Buffer objects are created in the GL server so that the client application can avoid uploading vertices, indices, texture image data, etc every time they are needed.</p>
<p>QGLBuffer objects can be copied around as a reference to the underlying GL buffer object:</p>
<pre class="highlightedCode brush: cpp"> QGLBuffer buffer1(QGLBuffer::IndexBuffer);
 buffer1.create();

 QGLBuffer buffer2 = buffer1;</pre>
<p>QGLBuffer performs a shallow copy when objects are copied in this manner, but does not implement copy-on-write semantics. The original object will be affected whenever the copy is modified.</p>
</div>
<!-- @@@QGLBuffer -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$Access$$$ReadOnly$$$WriteOnly$$$ReadWrite -->
<h3 class="fn"><a name="Access-enum"></a>enum QGLBuffer::Access</h3>
<p>This enum defines the access mode for <a href="qglbuffer.html#map">QGLBuffer::map</a>().</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::ReadOnly</tt></td><td class=" topAlign"><tt>0x88B8</tt></td><td  class="topAlign">The buffer will be mapped for reading only.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::WriteOnly</tt></td><td class=" topAlign"><tt>0x88B9</tt></td><td  class="topAlign">The buffer will be mapped for writing only.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::ReadWrite</tt></td><td class=" topAlign"><tt>0x88BA</tt></td><td  class="topAlign">The buffer will be mapped for reading and writing.</td></tr>
</table>
<!-- @@@Access -->
<!-- $$$Type$$$VertexBuffer$$$IndexBuffer$$$PixelPackBuffer$$$PixelUnpackBuffer -->
<h3 class="fn"><a name="Type-enum"></a>enum QGLBuffer::Type</h3>
<p>This enum defines the type of GL buffer object to create with <a href="qglbuffer.html">QGLBuffer</a>.</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::VertexBuffer</tt></td><td class=" topAlign"><tt>0x8892</tt></td><td  class="topAlign">Vertex buffer object for use when specifying vertex arrays.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::IndexBuffer</tt></td><td class=" topAlign"><tt>0x8893</tt></td><td  class="topAlign">Index buffer object for use with <tt>glDrawElements()</tt>.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::PixelPackBuffer</tt></td><td class=" topAlign"><tt>0x88EB</tt></td><td  class="topAlign">Pixel pack buffer object for reading pixel data from the GL server (for example, with <tt>glReadPixels()</tt>). Not supported under OpenGL/ES.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::PixelUnpackBuffer</tt></td><td class=" topAlign"><tt>0x88EC</tt></td><td  class="topAlign">Pixel unpack buffer object for writing pixel data to the GL server (for example, with <tt>glTexImage2D()</tt>). Not supported under OpenGL/ES.</td></tr>
</table>
<!-- @@@Type -->
<!-- $$$UsagePattern$$$StreamDraw$$$StreamRead$$$StreamCopy$$$StaticDraw$$$StaticRead$$$StaticCopy$$$DynamicDraw$$$DynamicRead$$$DynamicCopy -->
<h3 class="fn"><a name="UsagePattern-enum"></a>enum QGLBuffer::UsagePattern</h3>
<p>This enum defines the usage pattern of a <a href="qglbuffer.html">QGLBuffer</a> object.</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::StreamDraw</tt></td><td class=" topAlign"><tt>0x88E0</tt></td><td  class="topAlign">The data will be set once and used a few times for drawing operations. Under OpenGL/ES 1.1 this is identical to StaticDraw.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::StreamRead</tt></td><td class=" topAlign"><tt>0x88E1</tt></td><td  class="topAlign">The data will be set once and used a few times for reading data back from the GL server. Not supported under OpenGL/ES.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::StreamCopy</tt></td><td class=" topAlign"><tt>0x88E2</tt></td><td  class="topAlign">The data will be set once and used a few times for reading data back from the GL server for use in further drawing operations. Not supported under OpenGL/ES.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::StaticDraw</tt></td><td class=" topAlign"><tt>0x88E4</tt></td><td  class="topAlign">The data will be set once and used many times for drawing operations.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::StaticRead</tt></td><td class=" topAlign"><tt>0x88E5</tt></td><td  class="topAlign">The data will be set once and used many times for reading data back from the GL server. Not supported under OpenGL/ES.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::StaticCopy</tt></td><td class=" topAlign"><tt>0x88E6</tt></td><td  class="topAlign">The data will be set once and used many times for reading data back from the GL server for use in further drawing operations. Not supported under OpenGL/ES.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::DynamicDraw</tt></td><td class=" topAlign"><tt>0x88E8</tt></td><td  class="topAlign">The data will be modified repeatedly and used many times for drawing operations.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::DynamicRead</tt></td><td class=" topAlign"><tt>0x88E9</tt></td><td  class="topAlign">The data will be modified repeatedly and used many times for reading data back from the GL server. Not supported under OpenGL/ES.</td></tr>
<tr><td  class="topAlign"><tt>QGLBuffer::DynamicCopy</tt></td><td class=" topAlign"><tt>0x88EA</tt></td><td  class="topAlign">The data will be modified repeatedly and used many times for reading data back from the GL server for use in further drawing operations. Not supported under OpenGL/ES.</td></tr>
</table>
<!-- @@@UsagePattern -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QGLBuffer[overload1]$$$QGLBuffer -->
<h3 class="fn"><a name="QGLBuffer"></a>QGLBuffer::QGLBuffer ()</h3>
<p>Constructs a new buffer object of type <a href="qglbuffer.html#Type-enum">QGLBuffer::VertexBuffer</a>.</p>
<p>Note: this constructor just creates the <a href="qglbuffer.html">QGLBuffer</a> instance. The actual buffer object in the GL server is not created until <a href="qglbuffer.html#create">create</a>() is called.</p>
<p>See also <a href="qglbuffer.html#create">create</a>().</p>
<!-- @@@QGLBuffer -->
<!-- $$$QGLBuffer$$$QGLBufferQGLBuffer::Type -->
<h3 class="fn"><a name="QGLBuffer-2"></a>QGLBuffer::QGLBuffer ( <a href="qglbuffer.html#Type-enum">QGLBuffer::Type</a> <i>type</i> )</h3>
<p>Constructs a new buffer object of <i>type</i>.</p>
<p>Note: this constructor just creates the <a href="qglbuffer.html">QGLBuffer</a> instance. The actual buffer object in the GL server is not created until <a href="qglbuffer.html#create">create</a>() is called.</p>
<p>See also <a href="qglbuffer.html#create">create</a>().</p>
<!-- @@@QGLBuffer -->
<!-- $$$QGLBuffer$$$QGLBufferconstQGLBuffer& -->
<h3 class="fn"><a name="QGLBuffer-3"></a>QGLBuffer::QGLBuffer ( const QGLBuffer &amp; <i>other</i> )</h3>
<p>Constructs a shallow copy of <i>other</i>.</p>
<p>Note: <a href="qglbuffer.html">QGLBuffer</a> does not implement copy-on-write semantics, so <i>other</i> will be affected whenever the copy is modified.</p>
<!-- @@@QGLBuffer -->
<!-- $$$~QGLBuffer[overload1]$$$~QGLBuffer -->
<h3 class="fn"><a name="dtor.QGLBuffer"></a>QGLBuffer::~QGLBuffer ()</h3>
<p>Destroys this buffer object, including the storage being used in the GL server.</p>
<!-- @@@~QGLBuffer -->
<!-- $$$allocate[overload1]$$$allocateconstvoid*int -->
<h3 class="fn"><a name="allocate"></a>void QGLBuffer::allocate ( const void * <i>data</i>, int <i>count</i> )</h3>
<p>Allocates <i>count</i> bytes of space to the buffer, initialized to the contents of <i>data</i>. Any previous contents will be removed.</p>
<p>It is assumed that <a href="qglbuffer.html#create">create</a>() has been called on this buffer and that it has been bound to the current context.</p>
<p>See also <a href="qglbuffer.html#create">create</a>(), <a href="qglbuffer.html#read">read</a>(), and <a href="qglbuffer.html#write">write</a>().</p>
<!-- @@@allocate -->
<!-- $$$allocate$$$allocateint -->
<h3 class="fn"><a name="allocate-2"></a>void QGLBuffer::allocate ( int <i>count</i> )</h3>
<p>This is an overloaded function.</p>
<p>Allocates <i>count</i> bytes of space to the buffer. Any previous contents will be removed.</p>
<p>It is assumed that <a href="qglbuffer.html#create">create</a>() has been called on this buffer and that it has been bound to the current context.</p>
<p>See also <a href="qglbuffer.html#create">create</a>() and <a href="qglbuffer.html#write">write</a>().</p>
<!-- @@@allocate -->
<!-- $$$bind[overload1]$$$bind -->
<h3 class="fn"><a name="bind"></a>bool QGLBuffer::bind ()</h3>
<p>Binds the buffer associated with this object to the current GL context. Returns false if binding was not possible, usually because <a href="qglbuffer.html#type">type</a>() is not supported on this GL implementation.</p>
<p>The buffer must be bound to the same <a href="qglcontext.html">QGLContext</a> current when <a href="qglbuffer.html#create">create</a>() was called, or to another <a href="qglcontext.html">QGLContext</a> that is sharing with it. Otherwise, false will be returned from this function.</p>
<p>See also <a href="qglbuffer.html#release">release</a>() and <a href="qglbuffer.html#create">create</a>().</p>
<!-- @@@bind -->
<!-- $$$bufferId[overload1]$$$bufferId -->
<h3 class="fn"><a name="bufferId"></a>GLuint QGLBuffer::bufferId () const</h3>
<p>Returns the GL identifier associated with this buffer; zero if the buffer has not been created.</p>
<p>See also <a href="qglbuffer.html#isCreated">isCreated</a>().</p>
<!-- @@@bufferId -->
<!-- $$$create[overload1]$$$create -->
<h3 class="fn"><a name="create"></a>bool QGLBuffer::create ()</h3>
<p>Creates the buffer object in the GL server. Returns true if the object was created; false otherwise.</p>
<p>This function must be called with a current <a href="qglcontext.html">QGLContext</a>. The buffer will be bound to and can only be used in that context (or any other context that is shared with it).</p>
<p>This function will return false if the GL implementation does not support buffers, or there is no current <a href="qglcontext.html">QGLContext</a>.</p>
<p>See also <a href="qglbuffer.html#isCreated">isCreated</a>(), <a href="qglbuffer.html#allocate">allocate</a>(), <a href="qglbuffer.html#write">write</a>(), and <a href="qglbuffer.html#destroy">destroy</a>().</p>
<!-- @@@create -->
<!-- $$$destroy[overload1]$$$destroy -->
<h3 class="fn"><a name="destroy"></a>void QGLBuffer::destroy ()</h3>
<p>Destroys this buffer object, including the storage being used in the GL server. All references to the buffer will become invalid.</p>
<!-- @@@destroy -->
<!-- $$$isCreated[overload1]$$$isCreated -->
<h3 class="fn"><a name="isCreated"></a>bool QGLBuffer::isCreated () const</h3>
<p>Returns true if this buffer has been created; false otherwise.</p>
<p>See also <a href="qglbuffer.html#create">create</a>() and <a href="qglbuffer.html#destroy">destroy</a>().</p>
<!-- @@@isCreated -->
<!-- $$$map[overload1]$$$mapQGLBuffer::Access -->
<h3 class="fn"><a name="map"></a>void * QGLBuffer::map ( <a href="qglbuffer.html#Access-enum">QGLBuffer::Access</a> <i>access</i> )</h3>
<p>Maps the contents of this buffer into the application's memory space and returns a pointer to it. Returns null if memory mapping is not possible. The <i>access</i> parameter indicates the type of access to be performed.</p>
<p>It is assumed that <a href="qglbuffer.html#create">create</a>() has been called on this buffer and that it has been bound to the current context.</p>
<p>This function is only supported under OpenGL/ES if the <tt>GL_OES_mapbuffer</tt> extension is present.</p>
<p>See also <a href="qglbuffer.html#unmap">unmap</a>(), <a href="qglbuffer.html#create">create</a>(), and <a href="qglbuffer.html#bind">bind</a>().</p>
<!-- @@@map -->
<!-- $$$read[overload1]$$$readintvoid*int -->
<h3 class="fn"><a name="read"></a>bool QGLBuffer::read ( int <i>offset</i>, void * <i>data</i>, int <i>count</i> )</h3>
<p>Reads the <i>count</i> bytes in this buffer starting at <i>offset</i> into <i>data</i>. Returns true on success; false if reading from the buffer is not supported. Buffer reading is not supported under OpenGL/ES.</p>
<p>It is assumed that this buffer has been bound to the current context.</p>
<p>See also <a href="qglbuffer.html#write">write</a>() and <a href="qglbuffer.html#bind">bind</a>().</p>
<!-- @@@read -->
<!-- $$$release[overload1]$$$release -->
<h3 class="fn"><a name="release"></a>void QGLBuffer::release ()</h3>
<p>Releases the buffer associated with this object from the current GL context.</p>
<p>This function must be called with the same <a href="qglcontext.html">QGLContext</a> current as when <a href="qglbuffer.html#bind">bind</a>() was called on the buffer.</p>
<p>See also <a href="qglbuffer.html#bind">bind</a>().</p>
<!-- @@@release -->
<!-- $$$release$$$releaseQGLBuffer::Type -->
<h3 class="fn"><a name="release-2"></a>void QGLBuffer::release ( <a href="qglbuffer.html#Type-enum">QGLBuffer::Type</a> <i>type</i> )<tt> [static]</tt></h3>
<p>Releases the buffer associated with <i>type</i> in the current <a href="qglcontext.html">QGLContext</a>.</p>
<p>This function is a direct call to <tt>glBindBuffer(type, 0)</tt> for use when the caller does not know which <a href="qglbuffer.html">QGLBuffer</a> has been bound to the context but wants to make sure that it is released.</p>
<pre class="highlightedCode brush: cpp"> QGLBuffer::release(QGLBuffer::VertexBuffer);</pre>
<!-- @@@release -->
<!-- $$$setUsagePattern[overload1]$$$setUsagePatternQGLBuffer::UsagePattern -->
<h3 class="fn"><a name="setUsagePattern"></a>void QGLBuffer::setUsagePattern ( <a href="qglbuffer.html#UsagePattern-enum">QGLBuffer::UsagePattern</a> <i>value</i> )</h3>
<p>Sets the usage pattern for this buffer object to <i>value</i>. This function must be called before <a href="qglbuffer.html#allocate">allocate</a>() or <a href="qglbuffer.html#write">write</a>().</p>
<p>See also <a href="qglbuffer.html#usagePattern">usagePattern</a>(), <a href="qglbuffer.html#allocate">allocate</a>(), and <a href="qglbuffer.html#write">write</a>().</p>
<!-- @@@setUsagePattern -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn"><a name="size"></a>int QGLBuffer::size () const</h3>
<p>Returns the size of the data in this buffer, for reading operations. Returns -1 if fetching the buffer size is not supported, or the buffer has not been created.</p>
<p>It is assumed that this buffer has been bound to the current context.</p>
<p>See also <a href="qglbuffer.html#isCreated">isCreated</a>() and <a href="qglbuffer.html#bind">bind</a>().</p>
<!-- @@@size -->
<!-- $$$type[overload1]$$$type -->
<h3 class="fn"><a name="type"></a><a href="qglbuffer.html#Type-enum">QGLBuffer::Type</a> QGLBuffer::type () const</h3>
<p>Returns the type of buffer represented by this object.</p>
<!-- @@@type -->
<!-- $$$unmap[overload1]$$$unmap -->
<h3 class="fn"><a name="unmap"></a>bool QGLBuffer::unmap ()</h3>
<p>Unmaps the buffer after it was mapped into the application's memory space with a previous call to <a href="qglbuffer.html#map">map</a>(). Returns true if the unmap succeeded; false otherwise.</p>
<p>It is assumed that this buffer has been bound to the current context, and that it was previously mapped with <a href="qglbuffer.html#map">map</a>().</p>
<p>This function is only supported under OpenGL/ES if the <tt>GL_OES_mapbuffer</tt> extension is present.</p>
<p>See also <a href="qglbuffer.html#map">map</a>().</p>
<!-- @@@unmap -->
<!-- $$$usagePattern[overload1]$$$usagePattern -->
<h3 class="fn"><a name="usagePattern"></a><a href="qglbuffer.html#UsagePattern-enum">QGLBuffer::UsagePattern</a> QGLBuffer::usagePattern () const</h3>
<p>Returns the usage pattern for this buffer object. The default value is <a href="qglbuffer.html#UsagePattern-enum">StaticDraw</a>.</p>
<p>See also <a href="qglbuffer.html#setUsagePattern">setUsagePattern</a>().</p>
<!-- @@@usagePattern -->
<!-- $$$write[overload1]$$$writeintconstvoid*int -->
<h3 class="fn"><a name="write"></a>void QGLBuffer::write ( int <i>offset</i>, const void * <i>data</i>, int <i>count</i> )</h3>
<p>Replaces the <i>count</i> bytes of this buffer starting at <i>offset</i> with the contents of <i>data</i>. Any other bytes in the buffer will be left unmodified.</p>
<p>It is assumed that <a href="qglbuffer.html#create">create</a>() has been called on this buffer and that it has been bound to the current context.</p>
<p>See also <a href="qglbuffer.html#create">create</a>(), <a href="qglbuffer.html#read">read</a>(), and <a href="qglbuffer.html#allocate">allocate</a>().</p>
<!-- @@@write -->
<!-- $$$operator=[overload1]$$$operator=constQGLBuffer& -->
<h3 class="fn"><a name="operator-eq"></a>QGLBuffer &amp; QGLBuffer::operator= ( const QGLBuffer &amp; <i>other</i> )</h3>
<p>Assigns a shallow copy of <i>other</i> to this object.</p>
<p>Note: <a href="qglbuffer.html">QGLBuffer</a> does not implement copy-on-write semantics, so <i>other</i> will be affected whenever the copy is modified.</p>
<!-- @@@operator= -->
</div>
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
    <br />
    <p>
      Licensees holding valid Qt Commercial licenses may use this document in accordance with the      Qt Commercial License Agreement provided with the Software or, alternatively, in accordance      with the terms contained in a written agreement between you and Nokia.</p>
    <p>
      Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
      Free Documentation License version 1.3</a>
      as published by the Free Software Foundation.</p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback.</p> <p class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
</body>
</html>
