<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qgl.cpp -->
  <title>Qt 4.7: QGLContext Class Reference</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://doc.qt.nokia.com">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global Declarations</a></li> 
			   <li><a href="licensing.html">Licenses and Credits</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
			   <li><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="technology-apis.html">Qt and Key Technologies</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
			   <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
			   <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
			   <li class="defaultLink"><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li> 
			   <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
			   <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="modules.html">Modules</a></li>              <li><a href="qtopengl.html">QtOpenGL</a></li>
              <li>QGLContext</li>
            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types">Public Types</a></li>
<li class="level1"><a href="#public-functions">Public Functions</a></li>
<li class="level1"><a href="#static-public-members">Static Public Members</a></li>
<li class="level1"><a href="#protected-functions">Protected Functions</a></li>
<li class="level1"><a href="#details">Detailed Description</a></li>
</ul>
</div>
<h1 class="title">QGLContext Class Reference</h1>
<!-- $$$QGLContext-brief -->
<p>The QGLContext class encapsulates an OpenGL rendering context. <a href="#details">More...</a></p>
<!-- @@@QGLContext -->
<pre class="highlightedCode brush: cpp"> #include &lt;QGLContext&gt;</pre><ul>
<li><a href="qglcontext-members.html">List of all members, including inherited members</a></li>
<li><a href="qglcontext-obsolete.html">Obsolete members</a></li>
</ul>
<a name="public-types"></a>
<h2>Public Types</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#BindOption-enum">BindOption</a></b> { NoBindOption, InvertedYBindOption, MipmapBindOption, PremultipliedAlphaBindOption, LinearFilteringBindOption, DefaultBindOption }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#BindOption-enum">BindOptions</a></b></td></tr>
</table>
<a name="public-functions"></a>
<h2>Public Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#QGLContext">QGLContext</a></b> ( const QGLFormat &amp; <i>format</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#dtor.QGLContext">~QGLContext</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture">bindTexture</a></b> ( const QImage &amp; <i>image</i>, GLenum <i>target</i>, GLint <i>format</i>, BindOptions <i>options</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture-2">bindTexture</a></b> ( const QString &amp; <i>fileName</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture-3">bindTexture</a></b> ( const QImage &amp; <i>image</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLint <i>format</i> = GL_RGBA )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture-4">bindTexture</a></b> ( const QPixmap &amp; <i>pixmap</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLint <i>format</i> = GL_RGBA )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> GLuint </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#bindTexture-5">bindTexture</a></b> ( const QPixmap &amp; <i>pixmap</i>, GLenum <i>target</i>, GLint <i>format</i>, BindOptions <i>options</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#create">create</a></b> ( const QGLContext * <i>shareContext</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#deleteTexture">deleteTexture</a></b> ( GLuint <i>id</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPaintDevice * </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#device">device</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#doneCurrent">doneCurrent</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#drawTexture">drawTexture</a></b> ( const QRectF &amp; <i>target</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#drawTexture-2">drawTexture</a></b> ( const QPointF &amp; <i>point</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLFormat </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#format">format</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void * </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#getProcAddress">getProcAddress</a></b> ( const QString &amp; <i>proc</i> ) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#isSharing">isSharing</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#isValid">isValid</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#makeCurrent">makeCurrent</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QColor </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#overlayTransparentColor">overlayTransparentColor</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGLFormat </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#requestedFormat">requestedFormat</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#reset">reset</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#setFormat">setFormat</a></b> ( const QGLFormat &amp; <i>format</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#swapBuffers">swapBuffers</a></b> () const</td></tr>
</table>
<a name="static-public-members"></a>
<h2>Static Public Members</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#areSharing">areSharing</a></b> ( const QGLContext * <i>context1</i>, const QGLContext * <i>context2</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QGLContext * </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#currentContext">currentContext</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#setTextureCacheLimit">setTextureCacheLimit</a></b> ( int <i>size</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#textureCacheLimit">textureCacheLimit</a></b> ()</td></tr>
</table>
<a name="protected-functions"></a>
<h2>Protected Functions</h2>
<table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#chooseContext">chooseContext</a></b> ( const QGLContext * <i>shareContext</i> = 0 )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void * </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#chooseMacVisual">chooseMacVisual</a></b> ( GDHandle <i>handle</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#choosePixelFormat">choosePixelFormat</a></b> ( void * <i>dummyPfd</i>, HDC <i>pdc</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void * </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#chooseVisual">chooseVisual</a></b> ()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#deviceIsPixmap">deviceIsPixmap</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#initialized">initialized</a></b> () const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#setInitialized">setInitialized</a></b> ( bool <i>on</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#setWindowCreated">setWindowCreated</a></b> ( bool <i>on</i> )</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qglcontext.html#windowCreated">windowCreated</a></b> () const</td></tr>
</table>
<a name="details"></a>
<!-- $$$QGLContext-description -->
<div class="descr">
<h2>Detailed Description</h2>
<p>The QGLContext class encapsulates an OpenGL rendering context.</p>
<p>An OpenGL rendering context is a complete set of OpenGL state variables. The rendering context's <a href="qgl.html#FormatOption-enum">format</a> is set in the constructor, but it can also be set later with <a href="qglcontext.html#setFormat">setFormat</a>(). The format options that are actually set are returned by <a href="qglcontext.html#format">format</a>(); the options you asked for are returned by <a href="qglcontext.html#requestedFormat">requestedFormat</a>(). Note that after a QGLContext object has been constructed, the actual OpenGL context must be created by explicitly calling the <a href="qglcontext.html#create">create()</a> function. The <a href="qglcontext.html#makeCurrent">makeCurrent</a>() function makes this context the current rendering context. You can make <i>no</i> context current using <a href="qglcontext.html#doneCurrent">doneCurrent</a>(). The <a href="qglcontext.html#reset">reset</a>() function will reset the context and make it invalid.</p>
<p>You can examine properties of the context with, e.g&#x2e; <a href="qglcontext.html#isValid">isValid</a>(), <a href="qglcontext.html#isSharing">isSharing</a>(), <a href="qglcontext.html#initialized">initialized</a>(), <a href="qglcontext.html#windowCreated">windowCreated</a>() and <a href="qglcontext.html#overlayTransparentColor">overlayTransparentColor</a>().</p>
<p>If you're using double buffering you can swap the screen contents with the off-screen buffer using <a href="qglcontext.html#swapBuffers">swapBuffers</a>().</p>
<p>Please note that QGLContext is not thread safe.</p>
</div>
<!-- @@@QGLContext -->
<div class="types">
<h2>Member Type Documentation</h2>
<!-- $$$BindOption$$$NoBindOption$$$InvertedYBindOption$$$MipmapBindOption$$$PremultipliedAlphaBindOption$$$LinearFilteringBindOption$$$MemoryManagedBindOption$$$CanFlipNativePixmapBindOption$$$DefaultBindOption$$$InternalBindOption -->
<h3 class="flags"><a name="BindOption-enum"></a>enum QGLContext::BindOption<br/>flags QGLContext::BindOptions</h3>
<p>A set of options to decide how to bind a texture using <a href="qglcontext.html#bindTexture">bindTexture</a>().</p>
<table class="valuelist"><tr class="odd"><tr><th class="tblConst">Constant</th><th class="tblval">Value</th><th class="tbldscr">Description</th></tr>
<tr><td  class="topAlign"><tt>QGLContext::NoBindOption</tt></td><td class=" topAlign"><tt>0x0000</tt></td><td  class="topAlign">Don't do anything, pass the texture straight through.</td></tr>
<tr><td  class="topAlign"><tt>QGLContext::InvertedYBindOption</tt></td><td class=" topAlign"><tt>0x0001</tt></td><td  class="topAlign">Specifies that the texture should be flipped over the X axis so that the texture coordinate 0,0 corresponds to the top left corner. Inverting the texture implies a deep copy prior to upload.</td></tr>
<tr><td  class="topAlign"><tt>QGLContext::MipmapBindOption</tt></td><td class=" topAlign"><tt>0x0002</tt></td><td  class="topAlign">Specifies that <a href="qglcontext.html#bindTexture">bindTexture</a>() should try to generate mipmaps. If the GL implementation supports the <tt>GL_SGIS_generate_mipmap</tt> extension, mipmaps will be automatically generated for the texture. Mipmap generation is only supported for the <tt>GL_TEXTURE_2D</tt> target.</td></tr>
<tr><td  class="topAlign"><tt>QGLContext::PremultipliedAlphaBindOption</tt></td><td class=" topAlign"><tt>0x0004</tt></td><td  class="topAlign">Specifies that the image should be uploaded with premultiplied alpha and does a conversion accordingly.</td></tr>
<tr><td  class="topAlign"><tt>QGLContext::LinearFilteringBindOption</tt></td><td class=" topAlign"><tt>0x0008</tt></td><td  class="topAlign">Specifies that the texture filtering should be set to GL_LINEAR. Default is GL_NEAREST. If mipmap is also enabled, filtering will be set to GL_LINEAR_MIPMAP_LINEAR.</td></tr>
<tr><td  class="topAlign"><tt>QGLContext::DefaultBindOption</tt></td><td class=" topAlign"><tt>LinearFilteringBindOption | InvertedYBindOption | MipmapBindOption</tt></td><td  class="topAlign">In Qt 4.5 and earlier, <a href="qglcontext.html#bindTexture">bindTexture</a>() would mirror the image and automatically generate mipmaps. This option helps preserve this default behavior.</td></tr>
</table>
<p>Used by x11 from pixmap to choose whether or not it can bind the pixmap upside down or not.</p>
<p>Used by paint engines to indicate that the pixmap should be memory managed along side with the pixmap/image that it stems from, e.g&#x2e; installing destruction hooks in them.</p>
<p>This enum was introduced or modified in Qt 4.6.</p>
<p>The BindOptions type is a typedef for <a href="qflags.html">QFlags</a>&lt;BindOption&gt;. It stores an OR combination of BindOption values.</p>
<!-- @@@BindOption -->
</div>
<div class="func">
<h2>Member Function Documentation</h2>
<!-- $$$QGLContext[overload1]$$$QGLContextconstQGLFormat& -->
<h3 class="fn"><a name="QGLContext"></a>QGLContext::QGLContext ( const <a href="qglformat.html">QGLFormat</a> &amp; <i>format</i> )</h3>
<p>Constructs an OpenGL context with the given <i>format</i> which specifies several display options for the context.</p>
<p>If the underlying OpenGL/Window system cannot satisfy all the features requested in <i>format</i>, the nearest subset of features will be used. After creation, the <a href="qglcontext.html#format">format</a>() method will return the actual format obtained.</p>
<p>Note that after a <a href="qglcontext.html">QGLContext</a> object has been constructed, <a href="qglcontext.html#create">create</a>() must be called explicitly to create the actual OpenGL context. The context will be <a href="qglcontext.html#isValid">invalid</a> if it was not possible to obtain a GL context at all.</p>
<p>See also <a href="qglcontext.html#format">format</a>() and <a href="qglcontext.html#isValid">isValid</a>().</p>
<!-- @@@QGLContext -->
<!-- $$$~QGLContext[overload1]$$$~QGLContext -->
<h3 class="fn"><a name="dtor.QGLContext"></a>QGLContext::~QGLContext ()<tt> [virtual]</tt></h3>
<p>Destroys the OpenGL context and frees its resources.</p>
<!-- @@@~QGLContext -->
<!-- $$$areSharing[overload1]$$$areSharingconstQGLContext*constQGLContext* -->
<h3 class="fn"><a name="areSharing"></a>bool QGLContext::areSharing ( const QGLContext * <i>context1</i>, const QGLContext * <i>context2</i> )<tt> [static]</tt></h3>
<p>Returns true if <i>context1</i> and <i>context2</i> are sharing their GL resources such as textures, shader programs, etc; otherwise returns false.</p>
<p>This function was introduced in Qt 4.6.</p>
<!-- @@@areSharing -->
<!-- $$$bindTexture[overload1]$$$bindTextureconstQImage&GLenumGLintBindOptions -->
<h3 class="fn"><a name="bindTexture"></a>GLuint QGLContext::bindTexture ( const <a href="qimage.html">QImage</a> &amp; <i>image</i>, GLenum <i>target</i>, GLint <i>format</i>, <a href="qglcontext.html#BindOption-enum">BindOptions</a> <i>options</i> )</h3>
<p>Generates and binds a 2D GL texture to the current context, based on <i>image</i>. The generated texture id is returned and can be used in later <tt>glBindTexture()</tt> calls.</p>
<p>The <i>target</i> parameter specifies the texture target. The default target is <tt>GL_TEXTURE_2D</tt>.</p>
<p>The <i>format</i> parameter sets the internal format for the texture. The default format is <tt>GL_RGBA</tt>.</p>
<p>The binding <i>options</i> are a set of options used to decide how to bind the texture to the context.</p>
<p>The texture that is generated is cached, so multiple calls to bindTexture() with the same <a href="qimage.html">QImage</a> will return the same texture id.</p>
<p>Note that we assume default values for the glPixelStore() and glPixelTransfer() parameters.</p>
<p>This function was introduced in Qt 4.6.</p>
<p>See also <a href="qglcontext.html#deleteTexture">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQString& -->
<h3 class="fn"><a name="bindTexture-2"></a>GLuint QGLContext::bindTexture ( const <a href="qstring.html">QString</a> &amp; <i>fileName</i> )</h3>
<p>This is an overloaded function.</p>
<p>Reads the compressed texture file <i>fileName</i> and generates a 2D GL texture from it.</p>
<p>This function can load DirectDrawSurface (DDS) textures in the DXT1, DXT3 and DXT5 DDS formats if the <tt>GL_ARB_texture_compression</tt> and <tt>GL_EXT_texture_compression_s3tc</tt> extensions are supported.</p>
<p>Since 4.6&#x2e;1, textures in the ETC1 format can be loaded if the <tt>GL_OES_compressed_ETC1_RGB8_texture</tt> extension is supported and the ETC1 texture has been encapsulated in the PVR container format. Also, textures in the PVRTC2 and PVRTC4 formats can be loaded if the <tt>GL_IMG_texture_compression_pvrtc</tt> extension is supported.</p>
<p>See also <a href="qglcontext.html#deleteTexture">deleteTexture</a>().</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQImage&GLenumGLint -->
<h3 class="fn"><a name="bindTexture-3"></a>GLuint QGLContext::bindTexture ( const <a href="qimage.html">QImage</a> &amp; <i>image</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLint <i>format</i> = GL_RGBA )</h3>
<p>Generates and binds a 2D GL texture to the current context, based on <i>image</i>. The generated texture id is returned and can be used in later <tt>glBindTexture()</tt> calls.</p>
<p>This is an overloaded function.</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQPixmap&GLenumGLint -->
<h3 class="fn"><a name="bindTexture-4"></a>GLuint QGLContext::bindTexture ( const <a href="qpixmap.html">QPixmap</a> &amp; <i>pixmap</i>, GLenum <i>target</i> = GL_TEXTURE_2D, GLint <i>format</i> = GL_RGBA )</h3>
<p>This is an overloaded function.</p>
<p>Generates and binds a 2D GL texture based on <i>pixmap</i>.</p>
<!-- @@@bindTexture -->
<!-- $$$bindTexture$$$bindTextureconstQPixmap&GLenumGLintBindOptions -->
<h3 class="fn"><a name="bindTexture-5"></a>GLuint QGLContext::bindTexture ( const <a href="qpixmap.html">QPixmap</a> &amp; <i>pixmap</i>, GLenum <i>target</i>, GLint <i>format</i>, <a href="qglcontext.html#BindOption-enum">BindOptions</a> <i>options</i> )</h3>
<p>This is an overloaded function.</p>
<p>Generates and binds a 2D GL texture to the current context, based on <i>pixmap</i>.</p>
<p>This function was introduced in Qt 4.6.</p>
<!-- @@@bindTexture -->
<!-- $$$chooseContext[overload1]$$$chooseContextconstQGLContext* -->
<h3 class="fn"><a name="chooseContext"></a>bool QGLContext::chooseContext ( const QGLContext * <i>shareContext</i> = 0 )<tt> [virtual protected]</tt></h3>
<p>This semi-internal function is called by <a href="qglcontext.html#create">create</a>(). It creates a system-dependent OpenGL handle that matches the <a href="qglcontext.html#format">format</a>() of <i>shareContext</i> as closely as possible, returning true if successful or false if a suitable handle could not be found.</p>
<p>On Windows, it calls the virtual function <a href="qglcontext.html#choosePixelFormat">choosePixelFormat</a>(), which finds a matching pixel format identifier. On X11, it calls the virtual function <a href="qglcontext.html#chooseVisual">chooseVisual</a>() which finds an appropriate X visual. On other platforms it may work differently.</p>
<!-- @@@chooseContext -->
<!-- $$$chooseMacVisual[overload1]$$$chooseMacVisualGDHandle -->
<h3 class="fn"><a name="chooseMacVisual"></a>void * QGLContext::chooseMacVisual ( GDHandle <i>handle</i> )<tt> [virtual protected]</tt></h3>
<p><b>Mac OS X only:</b> This virtual function tries to find a visual that matches the format, reducing the demands if the original request cannot be met.</p>
<p>The algorithm for reducing the demands of the format is quite simple-minded, so override this method in your subclass if your application has spcific requirements on visual selection.</p>
<p>The <i>handle</i> argument is always zero and is not used</p>
<p>See also <a href="qglcontext.html#chooseContext">chooseContext</a>().</p>
<!-- @@@chooseMacVisual -->
<!-- $$$choosePixelFormat[overload1]$$$choosePixelFormatvoid*HDC -->
<h3 class="fn"><a name="choosePixelFormat"></a>int QGLContext::choosePixelFormat ( void * <i>dummyPfd</i>, HDC <i>pdc</i> )<tt> [virtual protected]</tt></h3>
<p><b>Win32 only:</b> This virtual function chooses a pixel format that matches the OpenGL <a href="qglcontext.html#setFormat">format</a>. Reimplement this function in a subclass if you need a custom context.</p>
<p><b>Warning:</b> The <i>dummyPfd</i> pointer and <i>pdc</i> are used as a <tt>PIXELFORMATDESCRIPTOR*</tt>. We use <tt>void</tt> to avoid using Windows-specific types in our header files.</p>
<p>See also <a href="qglcontext.html#chooseContext">chooseContext</a>().</p>
<!-- @@@choosePixelFormat -->
<!-- $$$chooseVisual[overload1]$$$chooseVisual -->
<h3 class="fn"><a name="chooseVisual"></a>void * QGLContext::chooseVisual ()<tt> [virtual protected]</tt></h3>
<p><b>X11 only:</b> This virtual function tries to find a visual that matches the format, reducing the demands if the original request cannot be met.</p>
<p>The algorithm for reducing the demands of the format is quite simple-minded, so override this method in your subclass if your application has spcific requirements on visual selection.</p>
<p>See also <a href="qglcontext.html#chooseContext">chooseContext</a>().</p>
<!-- @@@chooseVisual -->
<!-- $$$create[overload1]$$$createconstQGLContext* -->
<h3 class="fn"><a name="create"></a>bool QGLContext::create ( const QGLContext * <i>shareContext</i> = 0 )<tt> [virtual]</tt></h3>
<p>Creates the GL context. Returns true if it was successful in creating a valid GL rendering context on the paint device specified in the constructor; otherwise returns false (i.e&#x2e; the context is invalid).</p>
<p>After successful creation, <a href="qglcontext.html#format">format</a>() returns the set of features of the created GL rendering context.</p>
<p>If <i>shareContext</i> points to a valid <a href="qglcontext.html">QGLContext</a>, this method will try to establish OpenGL display list and texture object sharing between this context and the <i>shareContext</i>. Note that this may fail if the two contexts have different <a href="qglcontext.html#format">formats</a>. Use <a href="qglcontext.html#isSharing">isSharing</a>() to see if sharing is in effect.</p>
<p><b>Warning:</b> Implementation note: initialization of C++ class members usually takes place in the class constructor. <a href="qglcontext.html">QGLContext</a> is an exception because it must be simple to customize. The virtual functions <a href="qglcontext.html#chooseContext">chooseContext</a>() (and <a href="qglcontext.html#chooseVisual">chooseVisual</a>() for X11) can be reimplemented in a subclass to select a particular context. The problem is that virtual functions are not properly called during construction (even though this is correct C++) because C++ constructs class hierarchies from the bottom up. For this reason we need a create() function.</p>
<p>See also <a href="qglcontext.html#chooseContext">chooseContext</a>(), <a href="qglcontext.html#format">format</a>(), and <a href="qglcontext.html#isValid">isValid</a>().</p>
<!-- @@@create -->
<!-- $$$currentContext[overload1]$$$currentContext -->
<h3 class="fn"><a name="currentContext"></a>const QGLContext * QGLContext::currentContext ()<tt> [static]</tt></h3>
<p>Returns the current context, i.e&#x2e; the context to which any OpenGL commands will currently be directed. Returns 0 if no context is current.</p>
<p>See also <a href="qglcontext.html#makeCurrent">makeCurrent</a>().</p>
<!-- @@@currentContext -->
<!-- $$$deleteTexture[overload1]$$$deleteTextureGLuint -->
<h3 class="fn"><a name="deleteTexture"></a>void QGLContext::deleteTexture ( GLuint <i>id</i> )</h3>
<p>Removes the texture identified by <i>id</i> from the texture cache, and calls glDeleteTextures() to delete the texture from the context.</p>
<p>See also <a href="qglcontext.html#bindTexture">bindTexture</a>().</p>
<!-- @@@deleteTexture -->
<!-- $$$device[overload1]$$$device -->
<h3 class="fn"><a name="device"></a><a href="qpaintdevice.html">QPaintDevice</a> * QGLContext::device () const</h3>
<p>Returns the paint device set for this context.</p>
<p>See also <a href="qglcontext.html#QGLContext">QGLContext::QGLContext</a>().</p>
<!-- @@@device -->
<!-- $$$deviceIsPixmap[overload1]$$$deviceIsPixmap -->
<h3 class="fn"><a name="deviceIsPixmap"></a>bool QGLContext::deviceIsPixmap () const<tt> [protected]</tt></h3>
<p>Returns true if the paint device of this context is a pixmap; otherwise returns false.</p>
<!-- @@@deviceIsPixmap -->
<!-- $$$doneCurrent[overload1]$$$doneCurrent -->
<h3 class="fn"><a name="doneCurrent"></a>void QGLContext::doneCurrent ()<tt> [virtual]</tt></h3>
<p>Makes no GL context the current context. Normally, you do not need to call this function; <a href="qglcontext.html">QGLContext</a> calls it as necessary.</p>
<!-- @@@doneCurrent -->
<!-- $$$drawTexture[overload1]$$$drawTextureconstQRectF&GLuintGLenum -->
<h3 class="fn"><a name="drawTexture"></a>void QGLContext::drawTexture ( const <a href="qrectf.html">QRectF</a> &amp; <i>target</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D )</h3>
<p>This function supports the following use cases:</p>
<ul>
<li>On OpenGL and OpenGL ES 1.x it draws the given texture, <i>textureId</i>, to the given target rectangle, <i>target</i>, in OpenGL model space. The <i>textureTarget</i> should be a 2D texture target.</li>
<li>On OpenGL and OpenGL ES 2.x, if a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type <a href="qpaintengine.html#Type-enum">QPaintEngine::OpenGL2</a>, the function will draw the given texture, <i>textureId</i>, to the given target rectangle, <i>target</i>, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case, and that this is the only supported use case under OpenGL ES 2.x&#x2e;</li>
</ul>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$drawTexture$$$drawTextureconstQPointF&GLuintGLenum -->
<h3 class="fn"><a name="drawTexture-2"></a>void QGLContext::drawTexture ( const <a href="qpointf.html">QPointF</a> &amp; <i>point</i>, GLuint <i>textureId</i>, GLenum <i>textureTarget</i> = GL_TEXTURE_2D )</h3>
<p>This function supports the following use cases:</p>
<ul>
<li>By default it draws the given texture, <i>textureId</i>, at the given <i>point</i> in OpenGL model space. The <i>textureTarget</i> should be a 2D texture target.</li>
<li>If a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type <a href="qpaintengine.html#Type-enum">QPaintEngine::OpenGL2</a>, the function will draw the given texture, <i>textureId</i>, at the given <i>point</i>, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case.</li>
</ul>
<p><b>Note:</b> This function is not supported under any version of OpenGL ES.</p>
<p>This function was introduced in Qt 4.4.</p>
<!-- @@@drawTexture -->
<!-- $$$format[overload1]$$$format -->
<h3 class="fn"><a name="format"></a><a href="qglformat.html">QGLFormat</a> QGLContext::format () const</h3>
<p>Returns the frame buffer format that was obtained (this may be a subset of what was requested).</p>
<p>See also <a href="qglcontext.html#setFormat">setFormat</a>() and <a href="qglcontext.html#requestedFormat">requestedFormat</a>().</p>
<!-- @@@format -->
<!-- $$$getProcAddress[overload1]$$$getProcAddressconstQString& -->
<h3 class="fn"><a name="getProcAddress"></a>void * QGLContext::getProcAddress ( const <a href="qstring.html">QString</a> &amp; <i>proc</i> ) const</h3>
<p>Returns a function pointer to the GL extension function passed in <i>proc</i>. 0 is returned if a pointer to the function could not be obtained.</p>
<!-- @@@getProcAddress -->
<!-- $$$initialized[overload1]$$$initialized -->
<h3 class="fn"><a name="initialized"></a>bool QGLContext::initialized () const<tt> [protected]</tt></h3>
<p>Returns true if this context has been initialized, i.e&#x2e; if <a href="qglwidget.html#initializeGL">QGLWidget::initializeGL</a>() has been performed on it; otherwise returns false.</p>
<p>See also <a href="qglcontext.html#setInitialized">setInitialized</a>().</p>
<!-- @@@initialized -->
<!-- $$$isSharing[overload1]$$$isSharing -->
<h3 class="fn"><a name="isSharing"></a>bool QGLContext::isSharing () const</h3>
<p>Returns true if this context is sharing its GL context with another <a href="qglcontext.html">QGLContext</a>, otherwise false is returned. Note that context sharing might not be supported between contexts with different formats.</p>
<!-- @@@isSharing -->
<!-- $$$isValid[overload1]$$$isValid -->
<h3 class="fn"><a name="isValid"></a>bool QGLContext::isValid () const</h3>
<p>Returns true if a GL rendering context has been successfully created; otherwise returns false.</p>
<!-- @@@isValid -->
<!-- $$$makeCurrent[overload1]$$$makeCurrent -->
<h3 class="fn"><a name="makeCurrent"></a>void QGLContext::makeCurrent ()<tt> [virtual]</tt></h3>
<p>Makes this context the current OpenGL rendering context. All GL functions you call operate on this context until another context is made current.</p>
<p>In some very rare cases the underlying call may fail. If this occurs an error message is output to stderr.</p>
<!-- @@@makeCurrent -->
<!-- $$$overlayTransparentColor[overload1]$$$overlayTransparentColor -->
<h3 class="fn"><a name="overlayTransparentColor"></a><a href="qcolor.html">QColor</a> QGLContext::overlayTransparentColor () const</h3>
<p>If this context is a valid context in an overlay plane, returns the plane's transparent color. Otherwise returns an <a href="qcolor.html#isValid">invalid</a> color.</p>
<p>The returned color's <a href="qcolor.html#pixel" class="compat">pixel</a> value is the index of the transparent color in the colormap of the overlay plane. (Naturally, the color's RGB values are meaningless.)</p>
<p>The returned <a href="qcolor.html">QColor</a> object will generally work as expected only when passed as the argument to <a href="qglwidget.html#qglColor">QGLWidget::qglColor</a>() or <a href="qglwidget.html#qglClearColor">QGLWidget::qglClearColor</a>(). Under certain circumstances it can also be used to draw transparent graphics with a <a href="qpainter.html">QPainter</a>. See the examples/opengl/overlay_x11 example for details.</p>
<!-- @@@overlayTransparentColor -->
<!-- $$$requestedFormat[overload1]$$$requestedFormat -->
<h3 class="fn"><a name="requestedFormat"></a><a href="qglformat.html">QGLFormat</a> QGLContext::requestedFormat () const</h3>
<p>Returns the frame buffer format that was originally requested in the constructor or <a href="qglcontext.html#setFormat">setFormat</a>().</p>
<p>See also <a href="qglcontext.html#format">format</a>().</p>
<!-- @@@requestedFormat -->
<!-- $$$reset[overload1]$$$reset -->
<h3 class="fn"><a name="reset"></a>void QGLContext::reset ()</h3>
<p>Resets the context and makes it invalid.</p>
<p>See also <a href="qglcontext.html#create">create</a>() and <a href="qglcontext.html#isValid">isValid</a>().</p>
<!-- @@@reset -->
<!-- $$$setFormat[overload1]$$$setFormatconstQGLFormat& -->
<h3 class="fn"><a name="setFormat"></a>void QGLContext::setFormat ( const <a href="qglformat.html">QGLFormat</a> &amp; <i>format</i> )</h3>
<p>Sets a <i>format</i> for this context. The context is <a href="qglcontext.html#reset">reset</a>.</p>
<p>Call <a href="qglcontext.html#create">create</a>() to create a new GL context that tries to match the new format.</p>
<pre class="highlightedCode brush: cpp"> QGLContext *cx;
<span class="comment"> //  ...</span>
 QGLFormat f;
 f.setStereo(true);
 cx-&gt;setFormat(f);
 if (!cx-&gt;create())
     exit(); <span class="comment">// no OpenGL support, or cannot render on the specified paintdevice</span>
 if (!cx-&gt;format().stereo())
     exit(); <span class="comment">// could not create stereo context</span></pre>
<p>See also <a href="qglcontext.html#format">format</a>(), <a href="qglcontext.html#reset">reset</a>(), and <a href="qglcontext.html#create">create</a>().</p>
<!-- @@@setFormat -->
<!-- $$$setInitialized[overload1]$$$setInitializedbool -->
<h3 class="fn"><a name="setInitialized"></a>void QGLContext::setInitialized ( bool <i>on</i> )<tt> [protected]</tt></h3>
<p>If <i>on</i> is true the context has been initialized, i.e&#x2e; QGLContext::setInitialized() has been called on it. If <i>on</i> is false the context has not been initialized.</p>
<p>See also <a href="qglcontext.html#initialized">initialized</a>().</p>
<!-- @@@setInitialized -->
<!-- $$$setTextureCacheLimit[overload1]$$$setTextureCacheLimitint -->
<h3 class="fn"><a name="setTextureCacheLimit"></a>void QGLContext::setTextureCacheLimit ( int <i>size</i> )<tt> [static]</tt></h3>
<p>This function sets the limit for the texture cache to <i>size</i>, expressed in kilobytes.</p>
<p>By default, the cache limit is approximately 64 MB.</p>
<p>See also <a href="qglcontext.html#textureCacheLimit">textureCacheLimit</a>().</p>
<!-- @@@setTextureCacheLimit -->
<!-- $$$setWindowCreated[overload1]$$$setWindowCreatedbool -->
<h3 class="fn"><a name="setWindowCreated"></a>void QGLContext::setWindowCreated ( bool <i>on</i> )<tt> [protected]</tt></h3>
<p>If <i>on</i> is true the context has had a window created for it. If <i>on</i> is false no window has been created for the context.</p>
<p>See also <a href="qglcontext.html#windowCreated">windowCreated</a>().</p>
<!-- @@@setWindowCreated -->
<!-- $$$swapBuffers[overload1]$$$swapBuffers -->
<h3 class="fn"><a name="swapBuffers"></a>void QGLContext::swapBuffers () const<tt> [virtual]</tt></h3>
<p>Swaps the screen contents with an off-screen buffer. Only works if the context is in double buffer mode.</p>
<p>See also <a href="qglformat.html#setDoubleBuffer">QGLFormat::setDoubleBuffer</a>().</p>
<!-- @@@swapBuffers -->
<!-- $$$textureCacheLimit[overload1]$$$textureCacheLimit -->
<h3 class="fn"><a name="textureCacheLimit"></a>int QGLContext::textureCacheLimit ()<tt> [static]</tt></h3>
<p>Returns the current texture cache limit in kilobytes.</p>
<p>See also <a href="qglcontext.html#setTextureCacheLimit">setTextureCacheLimit</a>().</p>
<!-- @@@textureCacheLimit -->
<!-- $$$windowCreated[overload1]$$$windowCreated -->
<h3 class="fn"><a name="windowCreated"></a>bool QGLContext::windowCreated () const<tt> [protected]</tt></h3>
<p>Returns true if a window has been created for this context; otherwise returns false.</p>
<p>See also <a href="qglcontext.html#setWindowCreated">setWindowCreated</a>().</p>
<!-- @@@windowCreated -->
</div>
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
    <br />
    <p>
      Licensees holding valid Qt Commercial licenses may use this document in accordance with the      Qt Commercial License Agreement provided with the Software or, alternatively, in accordance      with the terms contained in a written agreement between you and Nokia.</p>
    <p>
      Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
      Free Documentation License version 1.3</a>
      as published by the Free Software Foundation.</p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback.</p> <p class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
</body>
</html>
