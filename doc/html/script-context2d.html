<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en_US" lang="en_US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- context2d.qdoc -->
  <title>Qt 4.7: Context2D Example</title>
  <link rel="stylesheet" type="text/css" href="style/style.css" />
  <script src="scripts/jquery.js" type="text/javascript"></script>
  <script src="scripts/functions.js" type="text/javascript"></script>
</head>
<body class="offline narrow creator">
 <div class="header" id="qtdocheader">
    <div class="content"> 
    <div id="nav-logo">
      <a href="index.html">Home</a></div>
    <a href="index.html" class="qtref"><span>Qt Reference Documentation</span></a>
    <div id="nav-topright">
      <ul>
        <li class="nav-topright-home"><a href="http://qt.nokia.com/">Qt HOME</a></li>
        <li class="nav-topright-dev"><a href="http://developer.qt.nokia.com/">DEV</a></li>
        <li class="nav-topright-labs"><a href="http://labs.qt.nokia.com/blogs/">LABS</a></li>
        <li class="nav-topright-doc nav-topright-doc-active"><a href="http://doc.qt.nokia.com/">
          DOC</a></li>
        <li class="nav-topright-blog"><a href="http://blog.qt.nokia.com/">BLOG</a></li>
      </ul>
    </div>
    <div id="shortCut">
      <ul>
        <li class="shortCut-topleft-inactive"><span><a href="index.html">Qt 4.7</a></span></li>
        <li class="shortCut-topleft-active"><a href="http://doc.qt.nokia.com">ALL VERSIONS        </a></li>
      </ul>
     </div>
 <ul class="sf-menu sf-js-enabled sf-shadow" id="narrowmenu"> 
		 <li><a href="#">API Lookup</a> 
			 <ul id="topmenuLook"> 
			   <li><a href="classes.html">Class index</a></li> 
 			  <li><a href="functions.html">Function index</a></li> 
			   <li><a href="modules.html">Modules</a></li> 
			   <li><a href="namespaces.html">Namespaces</a></li> 
			   <li><a href="qtglobal.html">Global Declarations</a></li> 
			   <li><a href="licensing.html">Licenses and Credits</a></li> 
			   </ul> 
		 </li> 
		 <li><a href="#">Qt Topics</a> 
			 <ul id="topmenuTopic"> 
			   <li><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
			   <li><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
			   <li><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li> 
			   <li><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li><a href="technology-apis.html">Qt and Key Technologies</a></li> 
			   <li><a href="best-practices.html">How-To's and Best Practices</a></li> 
			 </ul> 
		</li> 
		 <li><a href="#">Examples</a> 
			 <ul id="topmenuexample"> 
				 <li><a href="all-examples.html">Examples</a></li> 
				 <li><a href="tutorials.html">Tutorials</a></li> 
				 <li><a href="demos.html">Demos</a></li> 
				 <li><a href="qdeclarativeexamples.html">QML Examples</a></li> 
			 </ul> 
		 </li> 
 </ul> 
    </div>
  </div>
  <div class="wrapper">
    <div class="hd">
      <span></span>
    </div>
    <div class="bd group">
      <div class="sidebar">
        <div class="searchlabel">
          Search index:</div>
        <div class="search">
          <form id="qtdocsearch" action="" onsubmit="return false;">
            <fieldset>
              <input type="text" name="searchstring" id="pageType" value="" />
            </fieldset>
          </form>
        </div>
        <div class="box first bottombar" id="lookup">
          <h2 title="API Lookup"><span></span>
            API Lookup</h2>
          <div  id="list001" class="list">
          <ul id="ul001" >
              <li class="defaultLink"><a href="classes.html">Class index</a></li>
              <li class="defaultLink"><a href="functions.html">Function index</a></li>
              <li class="defaultLink"><a href="modules.html">Modules</a></li>
              <li class="defaultLink"><a href="namespaces.html">Namespaces</a></li>
              <li class="defaultLink"><a href="qtglobal.html">Global Declarations</a></li>
              <li class="defaultLink"><a href="qdeclarativeelements.html">QML elements</a></li>
            </ul> 
          </div>
        </div>
        <div class="box bottombar" id="topics">
          <h2 title="Qt Topics"><span></span>
            Qt Topics</h2>
          <div id="list002" class="list">
            <ul id="ul002" >
			   <li class="defaultLink"><a href="qt-basic-concepts.html">Programming with Qt</a></li> 
			   <li class="defaultLink"><a href="qtquick.html">Device UI's &amp; Qt Quick</a></li> 
			   <li class="defaultLink"><a href="qt-gui-concepts.html">UI Design with Qt</a></li> 
			   <li class="defaultLink"><a href="developing-with-qt.html">Cross-platform and Platform-specific</a></li> 
			   <li class="defaultLink"><a href="platform-specific.html">Platform-specific info</a></li> 
			   <li class="defaultLink"><a href="technology-apis.html">Qt and Key Technologies</a></li> 
			   <li class="defaultLink"><a href="best-practices.html">How-To's and Best Practices</a></li> 
            </ul>  
          </div>
        </div>
        <div class="box" id="examples">
          <h2 title="Examples"><span></span>
            Examples</h2>
          <div id="list003" class="list">
        <ul id="ul003">
              <li class="defaultLink"><a href="all-examples.html">Examples</a></li>
              <li class="defaultLink"><a href="tutorials.html">Tutorials</a></li>
              <li class="defaultLink"><a href="demos.html">Demos</a></li>
              <li class="defaultLink"><a href="qdeclarativeexamples.html">QML Examples</a></li>
            </ul> 
          </div>
        </div>
      </div>
      <div class="wrap">
        <div class="toolbar">
          <div class="breadcrumb toolblock">
            <ul>
              <li class="first"><a href="index.html">Home</a></li>
              <!--  Bread crumbs goes here -->
              <li><a href="all-examples.html">Examples</a></li>              <li>Context2D Example</li>            </ul>
          </div>
          <div class="toolbuttons toolblock">
            <ul>
              <li id="smallA" class="t_button">A</li>
              <li id="medA" class="t_button active">A</li>
              <li id="bigA" class="t_button">A</li>
              <li id="print" class="t_button"><a href="javascript:this.print();">
                <span>Print</span></a></li>
            </ul>
        </div>
        </div>
        <div class="content">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#using-the-html-canvas-element-in-a-web-browser">Using The HTML Canvas Element in a Web Browser</a></li>
<li class="level1"><a href="#using-qt-script-to-script-a-canvas">Using Qt Script to script a Canvas</a></li>
<li class="level1"><a href="#the-context2d-class">The Context2D Class</a></li>
<li class="level2"><a href="#implementation">Implementation</a></li>
<li class="level1"><a href="#the-canvas-widget">The Canvas Widget</a></li>
<li class="level1"><a href="#the-environment">The Environment</a></li>
<li class="level1"><a href="#the-application-window">The Application Window</a></li>
</ul>
</div>
<h1 class="title">Context2D Example</h1>
<span class="subtitle"></span>
<!-- $$$script/context2d-description -->
<div class="descr"> <a name="details"></a>
<p>Files:</p>
<ul>
<li><a href="script-context2d-context2d-cpp.html">script/context2d/context2d.cpp</a></li>
<li><a href="script-context2d-context2d-h.html">script/context2d/context2d.h</a></li>
<li><a href="script-context2d-domimage-cpp.html">script/context2d/domimage.cpp</a></li>
<li><a href="script-context2d-domimage-h.html">script/context2d/domimage.h</a></li>
<li><a href="script-context2d-environment-cpp.html">script/context2d/environment.cpp</a></li>
<li><a href="script-context2d-environment-h.html">script/context2d/environment.h</a></li>
<li><a href="script-context2d-qcontext2dcanvas-cpp.html">script/context2d/qcontext2dcanvas.cpp</a></li>
<li><a href="script-context2d-qcontext2dcanvas-h.html">script/context2d/qcontext2dcanvas.h</a></li>
<li><a href="script-context2d-window-cpp.html">script/context2d/window.cpp</a></li>
<li><a href="script-context2d-window-h.html">script/context2d/window.h</a></li>
<li><a href="script-context2d-scripts-alpha-js.html">script/context2d/scripts/alpha.js</a></li>
<li><a href="script-context2d-scripts-arc-js.html">script/context2d/scripts/arc.js</a></li>
<li><a href="script-context2d-scripts-bezier-js.html">script/context2d/scripts/bezier.js</a></li>
<li><a href="script-context2d-scripts-clock-js.html">script/context2d/scripts/clock.js</a></li>
<li><a href="script-context2d-scripts-fill1-js.html">script/context2d/scripts/fill1.js</a></li>
<li><a href="script-context2d-scripts-grad-js.html">script/context2d/scripts/grad.js</a></li>
<li><a href="script-context2d-scripts-linecap-js.html">script/context2d/scripts/linecap.js</a></li>
<li><a href="script-context2d-scripts-linestye-js.html">script/context2d/scripts/linestye.js</a></li>
<li><a href="script-context2d-scripts-moveto-js.html">script/context2d/scripts/moveto.js</a></li>
<li><a href="script-context2d-scripts-moveto2-js.html">script/context2d/scripts/moveto2.js</a></li>
<li><a href="script-context2d-scripts-pacman-js.html">script/context2d/scripts/pacman.js</a></li>
<li><a href="script-context2d-scripts-plasma-js.html">script/context2d/scripts/plasma.js</a></li>
<li><a href="script-context2d-scripts-pong-js.html">script/context2d/scripts/pong.js</a></li>
<li><a href="script-context2d-scripts-quad-js.html">script/context2d/scripts/quad.js</a></li>
<li><a href="script-context2d-scripts-rgba-js.html">script/context2d/scripts/rgba.js</a></li>
<li><a href="script-context2d-scripts-rotate-js.html">script/context2d/scripts/rotate.js</a></li>
<li><a href="script-context2d-scripts-scale-js.html">script/context2d/scripts/scale.js</a></li>
<li><a href="script-context2d-scripts-stroke1-js.html">script/context2d/scripts/stroke1.js</a></li>
<li><a href="script-context2d-scripts-translate-js.html">script/context2d/scripts/translate.js</a></li>
<li><a href="script-context2d-main-cpp.html">script/context2d/main.cpp</a></li>
<li><a href="script-context2d-context2d-pro.html">script/context2d/context2d.pro</a></li>
<li><a href="script-context2d-context2d-qrc.html">script/context2d/context2d.qrc</a></li>
</ul>
<p>This Qt Script example is an implementation of the Context2D API.</p>
<p class="centerAlign"><img src="images/context2d-example.png" /></p><p>Context2D is part of the specification for the HTML <tt>&lt;canvas&gt;</tt> element. It can be used to draw graphics via scripting. A good resource for learning more about the HTML <tt>&lt;canvas&gt;</tt> element is the <a href="http://developer.mozilla.org/en/docs/HTML:Canvas">Mozilla Developer Center</a>.</p>
<a name="using-the-html-canvas-element-in-a-web-browser"></a>
<h2>Using The HTML Canvas Element in a Web Browser</h2>
<p>First, let's look at how the <tt>&lt;canvas&gt;</tt> element is typically used in a web browser. The following HTML snippet defines a canvas of size 400x400 pixels with id <tt>mycanvas</tt>:</p>
<pre class="highlightedCode brush: cpp"> &lt;canvas width=&quot;400&quot; height=&quot;400&quot; id=&quot;mycanvas&quot;&gt;Fallback content goes here.&lt;/canvas&gt;</pre>
<p>To draw on the canvas, we must first obtain a reference to the DOM element corresponding to the <tt>&lt;canvas&gt;</tt> tag and then call the element's getContext() function. The resulting object implements the Context2D API that we use to draw.</p>
<pre class="highlightedCode brush: cpp"> &lt;script&gt;
 var canvas = document.getElementById(&quot;mycanvas&quot;);
 var ctx = canvas.getContext(&quot;2d&quot;);

<span class="comment"> // Draw a face</span>
 ctx.beginPath();
 ctx.arc(75,75,50,0,Math.PI*2,true); <span class="comment">// Outer circle</span>
 ctx.moveTo(110,75);
 ctx.arc(75,75,35,0,Math.PI,false);   <span class="comment">// Mouth</span>
 ctx.moveTo(65,65);
 ctx.arc(60,65,5,0,Math.PI*2,true);  <span class="comment">// Left eye</span>
 ctx.moveTo(95,65);
 ctx.arc(90,65,5,0,Math.PI*2,true);  <span class="comment">// Right eye</span>
 ctx.stroke();
 &lt;/script&gt;</pre>
<p>When the page is rendered by a browser that supports the <tt>&lt;canvas&gt;</tt> tag, this would be the result:</p>
<p class="centerAlign"><img src="images/context2d-example-smileysmile.png" /></p><a name="using-qt-script-to-script-a-canvas"></a>
<h2>Using Qt Script to script a Canvas</h2>
<p>The goal of this example is to be able to evaluate scripts that use the Context2D API, and render the results. Basic interaction (mouse, keyboard) should also be supported. In other words, we want to present scripts with an execution environment that very much resembles that of a web browser. Of course, our environment is only a small subset of what a browser provides; i.e&#x2e; we don't provide a full DOM API, only what is needed to run &quot;self-contained&quot; Context2D scripts (i.e&#x2e; scripts that don't depend on other parts of the DOM document).</p>
<p>Our &quot;Context2D-browser&quot; is set up through the following steps:</p>
<ul>
<li>Create an Environment.</li>
<li>Create a Context2D, and a QContext2DCanvas widget to render it.</li>
<li>Add the canvas object to the environment; this will enable scripts to obtain a reference to it.</li>
<li>Evaluate scripts in the environment.</li>
</ul>
<p>Once a script has been evaluated, the application handles any timer events and input events that occur subsequently (i.e&#x2e; forwards events to their associated script targets).</p>
<a name="the-context2d-class"></a>
<h2>The Context2D Class</h2>
<p>The &quot;heart&quot; of this example is the Context2D C++ class that implements the drawing API. Its interface is defined in terms of properties and slots. Note that this class isn't tied to Qt Script in any way.</p>
<pre class="highlightedCode brush: cpp"> class Context2D : public QObject
 {
     Q_OBJECT
     <span class="comment">// compositing</span>
     Q_PROPERTY(qreal globalAlpha READ globalAlpha WRITE setGlobalAlpha)
     Q_PROPERTY(QString globalCompositeOperation READ globalCompositeOperation WRITE setGlobalCompositeOperation)
     Q_PROPERTY(QVariant strokeStyle READ strokeStyle WRITE setStrokeStyle)
     Q_PROPERTY(QVariant fillStyle READ fillStyle WRITE setFillStyle)
     <span class="comment">// line caps/joins</span>
     Q_PROPERTY(qreal lineWidth READ lineWidth WRITE setLineWidth)
     Q_PROPERTY(QString lineCap READ lineCap WRITE setLineCap)
     Q_PROPERTY(QString lineJoin READ lineJoin WRITE setLineJoin)
     Q_PROPERTY(qreal miterLimit READ miterLimit WRITE setMiterLimit)
     <span class="comment">// shadows</span>
     Q_PROPERTY(qreal shadowOffsetX READ shadowOffsetX WRITE setShadowOffsetX)
     Q_PROPERTY(qreal shadowOffsetY READ shadowOffsetY WRITE setShadowOffsetY)
     Q_PROPERTY(qreal shadowBlur READ shadowBlur WRITE setShadowBlur)
     Q_PROPERTY(QString shadowColor READ shadowColor WRITE setShadowColor)</pre>
<p>The properties define various aspects of the Context2D configuration.</p>
<pre class="highlightedCode brush: cpp"> public slots:
     void save(); <span class="comment">// push state on state stack</span>
     void restore(); <span class="comment">// pop state stack and restore state</span>

     void scale(qreal x, qreal y);
     void rotate(qreal angle);
     void translate(qreal x, qreal y);
     void transform(qreal m11, qreal m12, qreal m21, qreal m22,
                    qreal dx, qreal dy);
     void setTransform(qreal m11, qreal m12, qreal m21, qreal m22,
                       qreal dx, qreal dy);

     CanvasGradient createLinearGradient(qreal x0, qreal y0,
                                         qreal x1, qreal y1);
     CanvasGradient createRadialGradient(qreal x0, qreal y0,
                                         qreal r0, qreal x1,
                                         qreal y1, qreal r1);

     <span class="comment">// rects</span>
     void clearRect(qreal x, qreal y, qreal w, qreal h);
     void fillRect(qreal x, qreal y, qreal w, qreal h);
     void strokeRect(qreal x, qreal y, qreal w, qreal h);

     <span class="comment">// path API</span>
     void beginPath();
     void closePath();
     void moveTo(qreal x, qreal y);
     void lineTo(qreal x, qreal y);
     void quadraticCurveTo(qreal cpx, qreal cpy, qreal x, qreal y);
     void bezierCurveTo(qreal cp1x, qreal cp1y,
                        qreal cp2x, qreal cp2y, qreal x, qreal y);
     void arcTo(qreal x1, qreal y1, qreal x2, qreal y2, qreal radius);
     void rect(qreal x, qreal y, qreal w, qreal h);
     void arc(qreal x, qreal y, qreal radius,
              qreal startAngle, qreal endAngle,
              bool anticlockwise);
     void fill();
     void stroke();
     void clip();
     bool isPointInPath(qreal x, qreal y) const;</pre>
<p>The slots define the operations that can be performed.</p>
<pre class="highlightedCode brush: cpp"> signals:
     void changed(const QImage &amp;image);</pre>
<p>The changed() signal is emitted when the contents of the drawing area has changed, so that clients associated with the Context2D object (i.e&#x2e; the canvas widget that renders it) are notified.</p>
<a name="implementation"></a>
<h3>Implementation</h3>
<p>Conveniently enough, the concepts, data structures and operations of the Context2D API map more or less directly to Qt's painting API. Conceptually, all we have to do is initialize a <a href="qpainter.html">QPainter</a> according to the Context2D properties, and use functions like <a href="qpainter.html#strokePath">QPainter::strokePath</a>() to do the painting. Painting is done on a <a href="qimage.html">QImage</a>.</p>
<pre class="highlightedCode brush: cpp"> QString Context2D::lineCap() const
 {
     switch (m_state.lineCap) {
     case Qt::FlatCap:
         return &quot;butt&quot;;
     case Qt::SquareCap:
         return &quot;square&quot;;
     case Qt::RoundCap:
         return &quot;round&quot;;
     default: ;
     }
     return QString();
 }

 void Context2D::setLineCap(const QString &amp;capString)
 {
     Qt::PenCapStyle style;
     if (capString == &quot;round&quot;)
         style = Qt::RoundCap;
     else if (capString == &quot;square&quot;)
         style = Qt::SquareCap;
     else <span class="comment">//if (capString == &quot;butt&quot;)</span>
         style = Qt::FlatCap;
     m_state.lineCap = style;
     m_state.flags |= DirtyLineCap;
 }</pre>
<p>The property accessors and most of the slots manipulate the internal Context2D state in some way. For the <tt>lineCap</tt> property, Context2D uses a string representation; we therefore have to map it from/to a <a href="qt.html#PenCapStyle-enum">Qt::PenCapStyle</a>. The <tt>lineJoin</tt> property is handled in the same fashion. All the property setters also set a <i>dirty flag</i> for the property; this is used to decide which aspects of the <a href="qpainter.html">QPainter</a> that need to be updated before doing the next painting operation.</p>
<pre class="highlightedCode brush: cpp"> void Context2D::setFillStyle(const QVariant &amp;style)
 {
     if (qVariantCanConvert&lt;CanvasGradient&gt;(style)) {
         CanvasGradient cg = qvariant_cast&lt;CanvasGradient&gt;(style);
         m_state.fillStyle = cg.value;
     } else {
         QColor color = colorFromString(style.toString());
         m_state.fillStyle = color;
     }
     m_state.flags |= DirtyFillStyle;
 }</pre>
<p>The implementation of the <tt>fillStyle</tt> property is interesting, since the value can be either a string or a <tt>CanvasGradient</tt>. We handle this by having the property be of type <a href="qvariant.html">QVariant</a>, and check the actual type of the value to see how to handle the write.</p>
<pre class="highlightedCode brush: cpp"> void Context2D::fillRect(qreal x, qreal y, qreal w, qreal h)
 {
     beginPainting();
     m_painter.save();
     m_painter.setMatrix(m_state.matrix, false);
     m_painter.fillRect(QRectF(x, y, w, h), m_painter.brush());
     m_painter.restore();
     scheduleChange();
 }</pre>
<p>Context2D does not have a concept of a paint event; painting operations can happen at any time. We would like to be efficient, and not have to call <a href="qpainter.html#begin">QPainter::begin</a>() and <a href="qpainter.html#end">QPainter::end</a>() for every painting operation, since typically many painting operations will follow in quick succession. The implementations of the painting operations use a helper function, beginPainting(), that activates the <a href="qpainter.html">QPainter</a> if it isn't active already, and updates the state of the <a href="qpainter.html">QPainter</a> (brush, pen, etc.) so that it reflects the current Context2D state.</p>
<pre class="highlightedCode brush: cpp"> void Context2D::scheduleChange()
 {
     if (m_changeTimerId == -1)
         m_changeTimerId = startTimer(0);
 }

 void Context2D::timerEvent(QTimerEvent *e)
 {
     if (e-&gt;timerId() == m_changeTimerId) {
         killTimer(m_changeTimerId);
         m_changeTimerId = -1;
         emit changed(endPainting());
     } else {
         QObject::timerEvent(e);
     }
 }</pre>
<p>The implementation of each painting operation ends by calling scheduleChange(), which will post a zero-timer event if one is not already pending. When the application returns to the event loop later (presumably after all the drawing operations have finished), the timer will trigger, <a href="qpainter.html#end">QPainter::end</a>() will be called, and the changed() signal is emitted with the new image as argument. The net effect is that there will typically be only a single (<a href="qpainter.html#begin">QPainter::begin</a>(), <a href="qpainter.html#end">QPainter::end</a>()) pair executed for the full sequence of painting operations.</p>
<a name="the-canvas-widget"></a>
<h2>The Canvas Widget</h2>
<pre class="highlightedCode brush: cpp"> class QContext2DCanvas : public QWidget
 {
     Q_OBJECT
 public:
     QContext2DCanvas(Context2D *context, Environment *env, QWidget *parent = 0);
     ~QContext2DCanvas();

     Context2D *context() const;
     void reset();

 public slots:
     QScriptValue getContext(const QString &amp;str);
     void resize(int width, int height);

     <span class="comment">// EventTarget</span>
     void addEventListener(const QString &amp;type, const QScriptValue &amp;listener,
                           bool useCapture);

 protected:
     virtual void paintEvent(QPaintEvent *e);
     virtual void mouseMoveEvent(QMouseEvent *e);
     virtual void mousePressEvent(QMouseEvent *e);
     virtual void mouseReleaseEvent(QMouseEvent *e);
     virtual void keyPressEvent(QKeyEvent *e);
     virtual void keyReleaseEvent(QKeyEvent *e);
     virtual void resizeEvent(QResizeEvent *e);

 private slots:
     void contentsChanged(const QImage &amp;image);</pre>
<p>The QContext2DCanvas class provides a widget that renders the contents of a Context2D object. It also provides a minimal scripting API, most notably the getContext() function.</p>
<pre class="highlightedCode brush: cpp"> QContext2DCanvas::QContext2DCanvas(Context2D *context, Environment *env, QWidget *parent)
     : QWidget(parent), m_context(context), m_env(env)
 {
     QObject::connect(context, SIGNAL(changed(QImage)), this, SLOT(contentsChanged(QImage)));
     setMouseTracking(true);
 }</pre>
<p>The constructor connects to the changed() signal of the Context2D object, so that the widget can update itself when it needs to do so. Mouse tracking is enabled so that mouse move events will be received even when no mouse buttons are depressed.</p>
<pre class="highlightedCode brush: cpp"> QScriptValue QContext2DCanvas::getContext(const QString &amp;str)
 {
     if (str != &quot;2d&quot;)
         return QScriptValue();
     return m_env-&gt;toWrapper(m_context);
 }</pre>
<p>The getContext() function asks the environment to wrap the Context2D object; the resulting proxy object makes the Context2D API available to scripts.</p>
<pre class="highlightedCode brush: cpp"> void QContext2DCanvas::contentsChanged(const QImage &amp;image)
 {
     m_image = image;
     update();
 }

 void QContext2DCanvas::paintEvent(QPaintEvent *e)
 {
     QPainter p(this);
 #ifdef Q_WS_S60
<span class="comment"> // Draw white rect first since in with some themes the js-file content will produce black-on-black.</span>
     QBrush whiteBgBrush(Qt::white);
     p.fillRect(e-&gt;rect(), whiteBgBrush);
 #endif
     p.setClipRect(e-&gt;rect());
     p.drawImage(0, 0, m_image);
 }</pre>
<p>The paintEvent() function simply paints the contents that was last received from the Context2D object.</p>
<pre class="highlightedCode brush: cpp"> void QContext2DCanvas::mouseMoveEvent(QMouseEvent *e)
 {
     m_env-&gt;handleEvent(this, e);
 }

 void QContext2DCanvas::mousePressEvent(QMouseEvent *e)
 {
     m_env-&gt;handleEvent(this, e);
 }

 void QContext2DCanvas::mouseReleaseEvent(QMouseEvent *e)
 {
     m_env-&gt;handleEvent(this, e);
 }

 void QContext2DCanvas::keyPressEvent(QKeyEvent *e)
 {
     m_env-&gt;handleEvent(this, e);
 }

 void QContext2DCanvas::keyReleaseEvent(QKeyEvent *e)
 {
     m_env-&gt;handleEvent(this, e);
 }</pre>
<p>The canvas widget reimplements mouse and key event handlers, and forwards these events to the scripting environment. The environment will take care of delivering the event to the proper script target, if any.</p>
<a name="the-environment"></a>
<h2>The Environment</h2>
<pre class="highlightedCode brush: cpp"> class Environment : public QObject
 {
     Q_OBJECT
     Q_PROPERTY(QScriptValue document READ document)
 public:
     Environment(QObject *parent = 0);
     ~Environment();

     QScriptValue document() const;

     void addCanvas(QContext2DCanvas *canvas);
     QContext2DCanvas *canvasByName(const QString &amp;name) const;
     QList&lt;QContext2DCanvas*&gt; canvases() const;

     QScriptValue evaluate(const QString &amp;code,
                           const QString &amp;fileName = QString());

     QScriptValue toWrapper(QObject *object);

     void handleEvent(QContext2DCanvas *canvas, QMouseEvent *e);
     void handleEvent(QContext2DCanvas *canvas, QKeyEvent *e);

     void reset();</pre>
<p>The Environment class provides a scripting environment where a Canvas C++ object can be registered, looked up by ID (name), and where scripts can be evaluated. The environment has a <tt>document</tt> property, just like the scripting environment of a web browser, so that scripts can call <tt>document.getElementById()</tt> to obtain a reference to a canvas.</p>
<pre class="highlightedCode brush: cpp"> public slots:
     int setInterval(const QScriptValue &amp;expression, int delay);
     void clearInterval(int timerId);

     int setTimeout(const QScriptValue &amp;expression, int delay);
     void clearTimeout(int timerId);</pre>
<p>The Environment class provides the timer attributes of the DOM Window Object interface. This enables us to support scripts that do animation, for example.</p>
<pre class="highlightedCode brush: cpp"> signals:
     void scriptError(const QScriptValue &amp;error);</pre>
<p>The scriptError() signal is emitted when evaluation of a script causes a script exception. For example, if a mouse press handler or timeout handler causes an exception, the environment's client(s) will be notified of this and can report the error.</p>
<pre class="highlightedCode brush: cpp"> Environment::Environment(QObject *parent)
     : QObject(parent)
 {
     m_engine = new QScriptEngine(this);

     m_document = m_engine-&gt;newQObject(
         new Document(this), QScriptEngine::QtOwnership,
         QScriptEngine::ExcludeSuperClassContents);

     CanvasGradientPrototype::setup(m_engine);

     m_originalGlobalObject = m_engine-&gt;globalObject();
     reset();
 }</pre>
<p>The constructor initializes the environment. First it creates the <a href="qscriptengine.html">QScriptEngine</a> that will be used to evaluate scripts. It creates the Document object that provides the getElementById() function. Note that the <a href="qscriptengine.html#QObjectWrapOption-enum">QScriptEngine::ExcludeSuperClassContents</a> flag is specified to avoid the wrapper objects from exposing properties and methods inherited from <a href="qobject.html">QObject</a>. Next, the environment wraps a pointer to <i>itself</i>; this is to prepare for setting this object as the script engine's Global Object. The properties of the standard Global Object are copied, so that these will also be available in our custom Global Object. We also create two self-references to the object; again, this is to provide a minimal level of compabilitity with the scripting environment that web browsers provide.</p>
<pre class="highlightedCode brush: cpp"> void Environment::addCanvas(QContext2DCanvas *canvas)
 {
     m_canvases.append(canvas);
 }

 QContext2DCanvas *Environment::canvasByName(const QString &amp;name) const
 {
     for (int i = 0; i &lt; m_canvases.size(); ++i) {
         QContext2DCanvas *canvas = m_canvases.at(i);
         if (canvas-&gt;objectName() == name)
             return canvas;
     }
     return 0;
 }</pre>
<p>The addCanvas() function adds the given canvas to the list of registered canvas objects. The canvasByName() function looks up a canvas by <a href="qobject.html#objectName-prop">QObject::objectName</a>(). This function is used to implement the <tt>document.getElementById()</tt> script function.</p>
<pre class="highlightedCode brush: cpp"> int Environment::setInterval(const QScriptValue &amp;expression, int delay)
 {
     if (expression.isString() || expression.isFunction()) {
         int timerId = startTimer(delay);
         m_intervalHash.insert(timerId, expression);
         return timerId;
     }
     return -1;
 }

 void Environment::clearInterval(int timerId)
 {
     killTimer(timerId);
     m_intervalHash.remove(timerId);
 }

 void Environment::timerEvent(QTimerEvent *event)
 {
     int id = event-&gt;timerId();
     QScriptValue expression = m_intervalHash.value(id);
     if (!expression.isValid()) {
         expression = m_timeoutHash.value(id);
         if (expression.isValid())
             killTimer(id);
     }
     if (expression.isString()) {
         evaluate(expression.toString());
     } else if (expression.isFunction()) {
         expression.call();
     }
     maybeEmitScriptError();
 }</pre>
<p>The setInterval() and clearInterval() implementations use a <a href="qhash.html">QHash</a> to map from timer ID to the <a href="qscriptvalue.html">QScriptValue</a> that holds the expression to evaluate when the timer is triggered. A helper function, maybeEmitScriptError(), is called after invoking the script handler; it will emit the scriptError() signal if the script engine has an uncaught exception.</p>
<pre class="highlightedCode brush: cpp"> QScriptValue Environment::toWrapper(QObject *object)
 {
     return m_engine-&gt;newQObject(object, QScriptEngine::QtOwnership,
                                 QScriptEngine::PreferExistingWrapperObject
                                 | QScriptEngine::ExcludeSuperClassContents);
 }</pre>
<p>The toWrapper() functions creates a <a href="qscriptvalue.html">QScriptValue</a> that wraps the given <a href="qobject.html">QObject</a>. Note that the <a href="qscriptengine.html#QObjectWrapOption-enum">QScriptEngine::PreferExistingWrapperObject</a> flag is specified; this guarantees that a single, unique wrapper object will be returned, even if toWrapper() is called several times with the same argument. This is important, since it is possible that a script can set new properties on the resulting wrapper object (e.g&#x2e; event handlers like <tt>onmousedown</tt>), and we want these to persist.</p>
<pre class="highlightedCode brush: cpp"> void Environment::handleEvent(QContext2DCanvas *canvas, QMouseEvent *e)
 {
     QString type;
     switch (e-&gt;type()) {
     case QEvent::MouseButtonPress:
         type = &quot;mousedown&quot;; break;
     case QEvent::MouseButtonRelease:
         type = &quot;mouseup&quot;; break;
     case QEvent::MouseMove:
         type = &quot;mousemove&quot;; break;
     default: break;
     }
     if (type.isEmpty())
         return;

     QScriptValue handlerObject;
     QScriptValue handler = eventHandler(canvas, type, &amp;handlerObject);
     if (!handler.isFunction())
         return;

     QScriptValue scriptEvent = newFakeDomEvent(type, toWrapper(canvas));
     <span class="comment">// MouseEvent</span>
     scriptEvent.setProperty(&quot;screenX&quot;, e-&gt;globalX(), QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;screenY&quot;, e-&gt;globalY(), QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;clientX&quot;, e-&gt;x(), QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;clientY&quot;, e-&gt;y(), QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;layerX&quot;, e-&gt;x(), QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;layerY&quot;, e-&gt;y(), QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;pageX&quot;, e-&gt;x(), QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;pageY&quot;, e-&gt;y(), QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;altKey&quot;, (e-&gt;modifiers() &amp; Qt::AltModifier) != 0,
                             QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;ctrlKey&quot;, (e-&gt;modifiers() &amp; Qt::ControlModifier) != 0,
                             QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;metaKey&quot;, (e-&gt;modifiers() &amp; Qt::MetaModifier) != 0,
                             QScriptValue::ReadOnly);
     scriptEvent.setProperty(&quot;shiftKey&quot;, (e-&gt;modifiers() &amp; Qt::ShiftModifier) != 0,
                             QScriptValue::ReadOnly);
     int button = 0;
     if (e-&gt;button() == Qt::RightButton)
         button = 2;
     else if (e-&gt;button() == Qt::MidButton)
         button = 1;
     scriptEvent.setProperty(&quot;button&quot;, button);
     scriptEvent.setProperty(&quot;relatedTarget&quot;, m_engine-&gt;nullValue(),
                             QScriptValue::ReadOnly);
     handler.call(handlerObject, QScriptValueList() &lt;&lt; scriptEvent);
     maybeEmitScriptError();
 }</pre>
<p>The handleEvent() function determines if there exists a handler for the given event in the environment, and if so, invokes that handler. Since the script expects a DOM event, the Qt C++ event must be converted to a DOM event before it is passed to the script. This mapping is relatively straightforward, but again, we only implement a subset of the full DOM API; just enough to get most scripts to work.</p>
<pre class="highlightedCode brush: cpp"> QScriptValue Environment::newFakeDomEvent(const QString &amp;type, const QScriptValue &amp;target)
 {
     QScriptValue e = m_engine-&gt;newObject();
     <span class="comment">// Event</span>
     e.setProperty(&quot;type&quot;, type, QScriptValue::ReadOnly);
     e.setProperty(&quot;bubbles&quot;, true, QScriptValue::ReadOnly);
     e.setProperty(&quot;cancelable&quot;, false, QScriptValue::ReadOnly);
     e.setProperty(&quot;target&quot;, target, QScriptValue::ReadOnly);
     e.setProperty(&quot;currentTarget&quot;, target, QScriptValue::ReadOnly);
     e.setProperty(&quot;eventPhase&quot;, 3); <span class="comment">// bubbling</span>
     e.setProperty(&quot;timeStamp&quot;, QDateTime::currentDateTime().toTime_t());
     <span class="comment">// UIEvent</span>
     e.setProperty(&quot;detail&quot;, 0, QScriptValue::ReadOnly);
     e.setProperty(&quot;view&quot;, m_engine-&gt;globalObject(), QScriptValue::ReadOnly);
     return e;
 }</pre>
<p>The newFakeDomEvent() function is a helper function that creates a new script object and initializes it with default values for the attributes defined in the DOM Event and DOM UIEvent interfaces.</p>
<pre class="highlightedCode brush: cpp"> class Document : public QObject
 {
     Q_OBJECT
 public:
     Document(Environment *env);
     ~Document();

 public slots:
     QScriptValue getElementById(const QString &amp;id) const;
     QScriptValue getElementsByTagName(const QString &amp;name) const;

     <span class="comment">// EventTarget</span>
     void addEventListener(const QString &amp;type, const QScriptValue &amp;listener,
                           bool useCapture);
 };</pre>
<p>The Document class defines two slots that become available to scripts: getElementById() and getElementsByTagName(). When the tag name is &quot;canvas&quot;, getElementsByTagName() will return a list of all canvas objects that are registered in the environment.</p>
<a name="the-application-window"></a>
<h2>The Application Window</h2>
<pre class="highlightedCode brush: cpp"> Window::Window(QWidget *parent)
     : QWidget(parent)
 #ifndef QT_NO_SCRIPTTOOLS
       , m_debugger(0), m_debugWindow(0)
 #endif
 {
     m_env = new Environment(this);
     QObject::connect(m_env, SIGNAL(scriptError(QScriptValue)),
                      this, SLOT(reportScriptError(QScriptValue)));

     Context2D *context = new Context2D(this);
     context-&gt;setSize(150, 150);
     m_canvas = new QContext2DCanvas(context, m_env, this);
     m_canvas-&gt;setFixedSize(context-&gt;size());
     m_canvas-&gt;setObjectName(&quot;tutorial&quot;);
     m_env-&gt;addCanvas(m_canvas);</pre>
<p>The Window constructor creates an Environment object and connects to its scriptError() signal. It then creates a Context2D object, and a QContext2DCanvas widget to hold it. The canvas widget is given the name <tt>tutorial</tt>, and added to the environment; scripts can access the canvas by e.g&#x2e; <tt>document.getElementById('tutorial')</tt>.</p>
<pre class="highlightedCode brush: cpp">     QDir dir(scriptsDir());
     QFileInfoList entries = dir.entryInfoList(QStringList() &lt;&lt; &quot;*.js&quot;);
     for (int i = 0; i &lt; entries.size(); ++i)
         m_view-&gt;addItem(entries.at(i).fileName());
     connect(m_view, SIGNAL(currentItemChanged(QListWidgetItem*,QListWidgetItem*)),
             this, SLOT(selectScript(QListWidgetItem*)));</pre>
<p>The window contains a list widget that is populated with available scripts (read from a <tt>scripts/</tt> folder).</p>
<pre class="highlightedCode brush: cpp"> void Window::selectScript(QListWidgetItem *item)
 {
     QString fileName = item-&gt;text();
     runScript(fileName, <span class="comment">/*debug=*/</span>false);
 }</pre>
<p>When an item is selected, the corresponding script is evaluated in the environment.</p>
<pre class="highlightedCode brush: cpp"> void Window::runInDebugger()
 {
     QListWidgetItem *item = m_view-&gt;currentItem();
     if (item) {
         QString fileName = item-&gt;text();
         runScript(fileName, <span class="comment">/*debug=*/</span>true);
     }
 }</pre>
<p>When the &quot;Run in Debugger&quot; button is clicked, the Qt Script debugger will automatically be invoked when the first statement of the script is reached. This enables the user to inspect the scripting environment and control further execution of the script; e.g&#x2e; he can single-step through the script and/or set breakpoints. It is also possible to enter script statements in the debugger's console widget, e.g&#x2e; to perform custom Context2D drawing operations, interactively.</p>
<pre class="highlightedCode brush: cpp"> void Window::runScript(const QString &amp;fileName, bool debug)
 {
     QFile file(scriptsDir() + &quot;/&quot; + fileName);
     file.open(QIODevice::ReadOnly);
     QString contents = file.readAll();
     file.close();
     m_env-&gt;reset();

 #ifndef QT_NO_SCRIPTTOOLS
     if (debug) {
         if (!m_debugger) {
             m_debugger = new QScriptEngineDebugger(this);
             m_debugWindow = m_debugger-&gt;standardWindow();
             m_debugWindow-&gt;setWindowModality(Qt::ApplicationModal);
             m_debugWindow-&gt;resize(1280, 704);
         }
         m_debugger-&gt;attachTo(m_env-&gt;engine());
         m_debugger-&gt;action(QScriptEngineDebugger::InterruptAction)-&gt;trigger();
     } else {
         if (m_debugger)
             m_debugger-&gt;detach();
     }
 #else
     Q_UNUSED(debug);
 #endif

     QScriptValue ret = m_env-&gt;evaluate(contents, fileName);

 #ifndef QT_NO_SCRIPTTOOLS
     if (m_debugWindow)
         m_debugWindow-&gt;hide();
 #endif

     if (ret.isError())
         reportScriptError(ret);
 }</pre>
<p>If the evaluation of a script causes an uncaught exception, the Qt Script debugger will automatically be invoked; this enables the user to get an idea of what went wrong.</p>
</div>
<!-- @@@script/context2d -->
        <div class="feedback t_button">
          [+] Documentation Feedback</div>
      </div>
    </div>
    </div> 
    <div class="ft">
      <span></span>
    </div>
  </div> 
  <div class="footer">
    <p>
      <acronym title="Copyright">&copy;</acronym> 2008-2010 Nokia Corporation and/or its
      subsidiaries. Nokia, Qt and their respective logos are trademarks of Nokia Corporation 
      in Finland and/or other countries worldwide.</p>
    <p>
      All other trademarks are property of their respective owners. <a title="Privacy Policy"
        href="http://qt.nokia.com/about/privacy-policy">Privacy Policy</a></p>
    <br />
    <p>
      Licensees holding valid Qt Commercial licenses may use this document in accordance with the      Qt Commercial License Agreement provided with the Software or, alternatively, in accordance      with the terms contained in a written agreement between you and Nokia.</p>
    <p>
      Alternatively, this document may be used under the terms of the <a href="http://www.gnu.org/licenses/fdl.html">GNU
      Free Documentation License version 1.3</a>
      as published by the Free Software Foundation.</p>
  </div>
  <div id="feedbackBox">
      <div id="feedcloseX" class="feedclose t_button">X</div>
    <form id="feedform" action="http://doc.qt.nokia.com/docFeedbck/feedback.php" method="get">
      <p id="noteHead">Thank you for giving your feedback.</p> <p class="note">Make sure it is related to this specific page. For more general bugs and 
      requests, please use the <a href="http://bugreports.qt.nokia.com/secure/Dashboard.jspa">Qt Bug Tracker</a>.</p>
      <p><textarea id="feedbox" name="feedText" rows="5" cols="40"></textarea></p>
      <p><input id="feedsubmit" class="feedclose" type="submit" name="feedback" /></p>
    </form>
  </div>
  <div id="blurpage">
  </div>
</body>
</html>
